import {
  __publicField
} from "./chunk-IVLCYF2H.js";

// node_modules/webgpu-utils/dist/0.x/webgpu-utils.module.js
var roundUpToMultipleOf = (v, multiple) => ((v + multiple - 1) / multiple | 0) * multiple;
var TypedArrayViewGenerator = class {
  constructor(sizeInBytes) {
    __publicField(this, "arrayBuffer");
    __publicField(this, "byteOffset");
    this.arrayBuffer = new ArrayBuffer(sizeInBytes);
    this.byteOffset = 0;
  }
  align(alignment) {
    this.byteOffset = roundUpToMultipleOf(this.byteOffset, alignment);
  }
  pad(numBytes) {
    this.byteOffset += numBytes;
  }
  getView(Ctor, numElements) {
    const view = new Ctor(this.arrayBuffer, this.byteOffset, numElements);
    this.byteOffset += view.byteLength;
    return view;
  }
};
function subarray(arr, offset, length) {
  return arr.subarray(offset, offset + length);
}
var isTypedArray = (arr) => arr && typeof arr.length === "number" && arr.buffer instanceof ArrayBuffer && typeof arr.byteLength === "number";
var b = {
  i32: { numElements: 1, align: 4, size: 4, type: "i32", View: Int32Array },
  u32: { numElements: 1, align: 4, size: 4, type: "u32", View: Uint32Array },
  f32: { numElements: 1, align: 4, size: 4, type: "f32", View: Float32Array },
  f16: { numElements: 1, align: 2, size: 2, type: "u16", View: Uint16Array },
  vec2f: { numElements: 2, align: 8, size: 8, type: "f32", View: Float32Array },
  vec2i: { numElements: 2, align: 8, size: 8, type: "i32", View: Int32Array },
  vec2u: { numElements: 2, align: 8, size: 8, type: "u32", View: Uint32Array },
  vec2h: { numElements: 2, align: 4, size: 4, type: "u16", View: Uint16Array },
  vec3i: { numElements: 3, align: 16, size: 12, type: "i32", View: Int32Array },
  vec3u: { numElements: 3, align: 16, size: 12, type: "u32", View: Uint32Array },
  vec3f: { numElements: 3, align: 16, size: 12, type: "f32", View: Float32Array },
  vec3h: { numElements: 3, align: 8, size: 6, type: "u16", View: Uint16Array },
  vec4i: { numElements: 4, align: 16, size: 16, type: "i32", View: Int32Array },
  vec4u: { numElements: 4, align: 16, size: 16, type: "u32", View: Uint32Array },
  vec4f: { numElements: 4, align: 16, size: 16, type: "f32", View: Float32Array },
  vec4h: { numElements: 4, align: 8, size: 8, type: "u16", View: Uint16Array },
  mat2x2f: { numElements: 4, align: 8, size: 16, type: "f32", View: Float32Array },
  mat2x2h: { numElements: 4, align: 4, size: 8, type: "u16", View: Uint16Array },
  mat3x2f: { numElements: 6, align: 8, size: 24, type: "f32", View: Float32Array },
  mat3x2h: { numElements: 6, align: 4, size: 12, type: "u16", View: Uint16Array },
  mat4x2f: { numElements: 8, align: 8, size: 32, type: "f32", View: Float32Array },
  mat4x2h: { numElements: 8, align: 4, size: 16, type: "u16", View: Uint16Array },
  mat2x3f: { numElements: 8, align: 16, size: 32, pad: [3, 1], type: "f32", View: Float32Array },
  mat2x3h: { numElements: 8, align: 8, size: 16, pad: [3, 1], type: "u16", View: Uint16Array },
  mat3x3f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: "f32", View: Float32Array },
  mat3x3h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: "u16", View: Uint16Array },
  mat4x3f: { numElements: 16, align: 16, size: 64, pad: [3, 1], type: "f32", View: Float32Array },
  mat4x3h: { numElements: 16, align: 8, size: 32, pad: [3, 1], type: "u16", View: Uint16Array },
  mat2x4f: { numElements: 8, align: 16, size: 32, type: "f32", View: Float32Array },
  mat2x4h: { numElements: 8, align: 8, size: 16, type: "u16", View: Uint16Array },
  mat3x4f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: "f32", View: Float32Array },
  mat3x4h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: "u16", View: Uint16Array },
  mat4x4f: { numElements: 16, align: 16, size: 64, type: "f32", View: Float32Array },
  mat4x4h: { numElements: 16, align: 8, size: 32, type: "u16", View: Uint16Array }
};
var typeInfo = {
  ...b,
  "vec2<i32>": b.vec2f,
  "vec2<u32>": b.vec2i,
  "vec2<f32>": b.vec2u,
  "vec2<f16>": b.vec2h,
  "vec3<i32>": b.vec3i,
  "vec3<u32>": b.vec3u,
  "vec3<f32>": b.vec3f,
  "vec3<f16>": b.vec3h,
  "vec4<i32>": b.vec4i,
  "vec4<u32>": b.vec4u,
  "vec4<f32>": b.vec4f,
  "vec4<f16>": b.vec4h,
  "mat2x2<f32>": b.mat2x2f,
  "mat2x2<f16>": b.mat2x2h,
  "mat3x2<f32>": b.mat3x2f,
  "mat3x2<f16>": b.mat3x2h,
  "mat4x2<f32>": b.mat4x2f,
  "mat4x2<f16>": b.mat4x2h,
  "mat2x3<f32>": b.mat2x3f,
  "mat2x3<f16>": b.mat2x3h,
  "mat3x3<f32>": b.mat3x3f,
  "mat3x3<f16>": b.mat3x3h,
  "mat4x3<f32>": b.mat4x3f,
  "mat4x3<f16>": b.mat4x3h,
  "mat2x4<f32>": b.mat2x4f,
  "mat2x4<f16>": b.mat2x4h,
  "mat3x4<f32>": b.mat3x4f,
  "mat3x4<f16>": b.mat3x4h,
  "mat4x4<f32>": b.mat4x4f,
  "mat4x4<f16>": b.mat4x4h
};
function getSizeOfStructDef(fieldDef) {
  if (Array.isArray(fieldDef)) {
    return fieldDef.length * getSizeOfStructDef(fieldDef[0]);
  } else {
    return fieldDef.size;
  }
}
function makeTypedArrayViews(structDef, arrayBuffer, offset) {
  const baseOffset = offset || 0;
  const buffer = arrayBuffer || new ArrayBuffer(getSizeOfStructDef(structDef));
  const makeViews = (structDef2) => {
    if (Array.isArray(structDef2)) {
      return structDef2.map((elemDef) => makeViews(elemDef));
    } else if (typeof structDef2 === "string") {
      throw Error("unreachable");
    } else {
      const fields = structDef2.fields;
      if (fields) {
        const views = {};
        for (const [name, def] of Object.entries(fields)) {
          views[name] = makeViews(def);
        }
        return views;
      } else {
        const { size, offset: offset2, type } = structDef2;
        try {
          const { View } = typeInfo[type];
          const numElements = size / View.BYTES_PER_ELEMENT;
          return new View(buffer, baseOffset + offset2, numElements);
        } catch {
          throw new Error(`unknown type: ${type}`);
        }
      }
    }
  };
  return { views: makeViews(structDef), arrayBuffer: buffer };
}
function setStructuredView(data, views) {
  if (data === void 0) {
    return;
  } else if (isTypedArray(views)) {
    const view = views;
    if (view.length === 1 && typeof data === "number") {
      view[0] = data;
    } else {
      if (Array.isArray(data[0]) || isTypedArray(data[0])) {
        const dataLen = data[0].length;
        const stride = dataLen === 3 ? 4 : dataLen;
        for (let i = 0; i < data.length; ++i) {
          const offset = i * stride;
          view.set(data[i], offset);
        }
      } else {
        view.set(data);
      }
    }
  } else if (Array.isArray(views)) {
    const asArray = views;
    data.forEach((newValue, ndx) => {
      setStructuredView(newValue, asArray[ndx]);
    });
  } else {
    const asViews = views;
    for (const [key, newValue] of Object.entries(data)) {
      const view = asViews[key];
      if (view) {
        setStructuredView(newValue, view);
      }
    }
  }
}
function makeStructuredView(structDef, arrayBuffer, offset = 0) {
  const views = makeTypedArrayViews(structDef, arrayBuffer, offset);
  return {
    ...views,
    set(data) {
      setStructuredView(data, views.views);
    }
  };
}
var s_views = /* @__PURE__ */ new WeakMap();
function getViewsByCtor(arrayBuffer) {
  let viewsByCtor = s_views.get(arrayBuffer);
  if (!viewsByCtor) {
    viewsByCtor = /* @__PURE__ */ new Map();
    s_views.set(arrayBuffer, viewsByCtor);
  }
  return viewsByCtor;
}
function getView(arrayBuffer, Ctor) {
  const viewsByCtor = getViewsByCtor(arrayBuffer);
  let view = viewsByCtor.get(Ctor);
  if (!view) {
    view = new Ctor(arrayBuffer);
    viewsByCtor.set(Ctor, view);
  }
  return view;
}
function setStructuredValues(fieldDef, data, arrayBuffer, offset = 0) {
  const asIntrinsicDefinition = fieldDef;
  if (asIntrinsicDefinition.type) {
    const type = typeInfo[asIntrinsicDefinition.type];
    const view = getView(arrayBuffer, type.View);
    const index = (offset + asIntrinsicDefinition.offset) / view.BYTES_PER_ELEMENT;
    if (typeof data === "number") {
      view[index] = data;
    } else {
      view.set(data, index);
    }
  } else if (Array.isArray(fieldDef)) {
    data.forEach((newValue, ndx) => {
      setStructuredValues(fieldDef[ndx], newValue, arrayBuffer, offset);
    });
  } else {
    const asStructDefinition = fieldDef;
    for (const [key, newValue] of Object.entries(data)) {
      const fieldDef2 = asStructDefinition.fields[key];
      if (fieldDef2) {
        setStructuredValues(fieldDef2, newValue, arrayBuffer, offset);
      }
    }
  }
}
var ParseContext = class {
  constructor() {
    this.constants = /* @__PURE__ */ new Map();
    this.aliases = /* @__PURE__ */ new Map();
    this.structs = /* @__PURE__ */ new Map();
  }
};
var Node = class {
  constructor() {
  }
  get isAstNode() {
    return true;
  }
  get astNodeType() {
    return "";
  }
  evaluate(context) {
    throw new Error("Cannot evaluate node");
  }
  evaluateString(context) {
    return this.evaluate(context).toString();
  }
};
var Statement = class extends Node {
  constructor() {
    super();
  }
};
var Function = class extends Statement {
  constructor(name, args, returnType, body) {
    super();
    this.name = name;
    this.args = args;
    this.returnType = returnType;
    this.body = body;
  }
  get astNodeType() {
    return "function";
  }
};
var StaticAssert = class extends Statement {
  constructor(expression) {
    super();
    this.expression = expression;
  }
  get astNodeType() {
    return "staticAssert";
  }
};
var While = class extends Statement {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "while";
  }
};
var For = class extends Statement {
  constructor(init, condition, increment, body) {
    super();
    this.init = init;
    this.condition = condition;
    this.increment = increment;
    this.body = body;
  }
  get astNodeType() {
    return "for";
  }
};
var Var = class extends Statement {
  constructor(name, type, storage, access, value) {
    super();
    this.name = name;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "var";
  }
};
var Let = class extends Statement {
  constructor(name, type, storage, access, value) {
    super();
    this.name = name;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "let";
  }
};
var Const = class extends Statement {
  constructor(name, type, storage, access, value) {
    super();
    this.name = name;
    this.type = type;
    this.storage = storage;
    this.access = access;
    this.value = value;
  }
  get astNodeType() {
    return "const";
  }
  evaluate(context) {
    return this.value.evaluate(context);
  }
};
var IncrementOperator;
(function(IncrementOperator2) {
  IncrementOperator2["increment"] = "++";
  IncrementOperator2["decrement"] = "--";
})(IncrementOperator || (IncrementOperator = {}));
(function(IncrementOperator2) {
  function parse(val) {
    const key = val;
    if (key == "parse")
      throw new Error("Invalid value for IncrementOperator");
    return IncrementOperator2[key];
  }
  IncrementOperator2.parse = parse;
})(IncrementOperator || (IncrementOperator = {}));
var Increment = class extends Statement {
  constructor(operator, variable) {
    super();
    this.operator = operator;
    this.variable = variable;
  }
  get astNodeType() {
    return "increment";
  }
};
var AssignOperator;
(function(AssignOperator2) {
  AssignOperator2["assign"] = "=";
  AssignOperator2["addAssign"] = "+=";
  AssignOperator2["subtractAssin"] = "-=";
  AssignOperator2["multiplyAssign"] = "*=";
  AssignOperator2["divideAssign"] = "/=";
  AssignOperator2["moduloAssign"] = "%=";
  AssignOperator2["andAssign"] = "&=";
  AssignOperator2["orAssign"] = "|=";
  AssignOperator2["xorAssign"] = "^=";
  AssignOperator2["shiftLeftAssign"] = "<<=";
  AssignOperator2["shiftRightAssign"] = ">>=";
})(AssignOperator || (AssignOperator = {}));
(function(AssignOperator2) {
  function parse(val) {
    const key = val;
    if (key == "parse")
      throw new Error("Invalid value for AssignOperator");
    return AssignOperator2[key];
  }
  AssignOperator2.parse = parse;
})(AssignOperator || (AssignOperator = {}));
var Assign = class extends Statement {
  constructor(operator, variable, value) {
    super();
    this.operator = operator;
    this.variable = variable;
    this.value = value;
  }
  get astNodeType() {
    return "assign";
  }
};
var Call = class extends Statement {
  constructor(name, args) {
    super();
    this.name = name;
    this.args = args;
  }
  get astNodeType() {
    return "call";
  }
};
var Loop = class extends Statement {
  constructor(body, continuing) {
    super();
    this.body = body;
    this.continuing = continuing;
  }
  get astNodeType() {
    return "loop";
  }
};
var Switch = class extends Statement {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "body";
  }
};
var If = class extends Statement {
  constructor(condition, body, elseif, _else) {
    super();
    this.condition = condition;
    this.body = body;
    this.elseif = elseif;
    this.else = _else;
  }
  get astNodeType() {
    return "if";
  }
};
var Return = class extends Statement {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "return";
  }
};
var Struct = class extends Statement {
  constructor(name, members) {
    super();
    this.name = name;
    this.members = members;
  }
  get astNodeType() {
    return "struct";
  }
  getMemberIndex(name) {
    for (let i = 0; i < this.members.length; i++) {
      if (this.members[i].name == name)
        return i;
    }
    return -1;
  }
};
var Enable = class extends Statement {
  constructor(name) {
    super();
    this.name = name;
  }
  get astNodeType() {
    return "enable";
  }
};
var Alias = class extends Statement {
  constructor(name, type) {
    super();
    this.name = name;
    this.type = type;
  }
  get astNodeType() {
    return "alias";
  }
};
var Discard = class extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
};
var Break = class extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "break";
  }
};
var Continue = class extends Statement {
  constructor() {
    super();
  }
  get astNodeType() {
    return "continue";
  }
};
var Type = class extends Node {
  constructor(name) {
    super();
    this.name = name;
  }
  get astNodeType() {
    return "type";
  }
};
var TemplateType = class extends Type {
  constructor(name, format, access) {
    super(name);
    this.format = format;
    this.access = access;
  }
  get astNodeType() {
    return "template";
  }
};
var PointerType = class extends Type {
  constructor(name, storage, type, access) {
    super(name);
    this.storage = storage;
    this.type = type;
    this.access = access;
  }
  get astNodeType() {
    return "pointer";
  }
};
var ArrayType = class extends Type {
  constructor(name, attributes, format, count) {
    super(name);
    this.attributes = attributes;
    this.format = format;
    this.count = count;
  }
  get astNodeType() {
    return "array";
  }
};
var SamplerType = class extends Type {
  constructor(name, format, access) {
    super(name);
    this.format = format;
    this.access = access;
  }
  get astNodeType() {
    return "sampler";
  }
};
var Expression = class extends Node {
  constructor() {
    super();
  }
};
var StringExpr = class extends Expression {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  evaluateString() {
    return this.value;
  }
};
var CreateExpr = class extends Expression {
  constructor(type, args) {
    super();
    this.type = type;
    this.args = args;
  }
  get astNodeType() {
    return "createExpr";
  }
};
var CallExpr = class extends Expression {
  constructor(name, args) {
    super();
    this.name = name;
    this.args = args;
  }
  get astNodeType() {
    return "callExpr";
  }
  evaluate(context) {
    switch (this.name) {
      case "abs":
        return Math.abs(this.args[0].evaluate(context));
      case "acos":
        return Math.acos(this.args[0].evaluate(context));
      case "acosh":
        return Math.acosh(this.args[0].evaluate(context));
      case "asin":
        return Math.asin(this.args[0].evaluate(context));
      case "asinh":
        return Math.asinh(this.args[0].evaluate(context));
      case "atan":
        return Math.atan(this.args[0].evaluate(context));
      case "atan2":
        return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "atanh":
        return Math.atanh(this.args[0].evaluate(context));
      case "ceil":
        return Math.ceil(this.args[0].evaluate(context));
      case "clamp":
        return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));
      case "cos":
        return Math.cos(this.args[0].evaluate(context));
      case "degrees":
        return this.args[0].evaluate(context) * 180 / Math.PI;
      case "distance":
        return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));
      case "dot":
      case "exp":
        return Math.exp(this.args[0].evaluate(context));
      case "exp2":
        return Math.pow(2, this.args[0].evaluate(context));
      case "floor":
        return Math.floor(this.args[0].evaluate(context));
      case "fma":
        return this.args[0].evaluate(context) * this.args[1].evaluate(context) + this.args[2].evaluate(context);
      case "fract":
        return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
      case "inverseSqrt":
        return 1 / Math.sqrt(this.args[0].evaluate(context));
      case "log":
        return Math.log(this.args[0].evaluate(context));
      case "log2":
        return Math.log2(this.args[0].evaluate(context));
      case "max":
        return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "min":
        return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "mix":
        return this.args[0].evaluate(context) * (1 - this.args[2].evaluate(context)) + this.args[1].evaluate(context) * this.args[2].evaluate(context);
      case "modf":
        return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
      case "pow":
        return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));
      case "radians":
        return this.args[0].evaluate(context) * Math.PI / 180;
      case "round":
        return Math.round(this.args[0].evaluate(context));
      case "sign":
        return Math.sign(this.args[0].evaluate(context));
      case "sin":
        return Math.sin(this.args[0].evaluate(context));
      case "sinh":
        return Math.sinh(this.args[0].evaluate(context));
      case "saturate":
        return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);
      case "smoothstep":
        return this.args[0].evaluate(context) * this.args[0].evaluate(context) * (3 - 2 * this.args[0].evaluate(context));
      case "sqrt":
        return Math.sqrt(this.args[0].evaluate(context));
      case "step":
        return this.args[0].evaluate(context) < this.args[1].evaluate(context) ? 0 : 1;
      case "tan":
        return Math.tan(this.args[0].evaluate(context));
      case "tanh":
        return Math.tanh(this.args[0].evaluate(context));
      case "trunc":
        return Math.trunc(this.args[0].evaluate(context));
      default:
        throw new Error("Non const function: " + this.name);
    }
  }
};
var VariableExpr = class extends Expression {
  constructor(name) {
    super();
    this.name = name;
  }
  get astNodeType() {
    return "varExpr";
  }
};
var ConstExpr = class extends Expression {
  constructor(name, initializer) {
    super();
    this.name = name;
    this.initializer = initializer;
  }
  get astNodeType() {
    return "constExpr";
  }
  evaluate(context) {
    var _a2, _b;
    if (this.initializer instanceof CreateExpr) {
      const property = (_a2 = this.postfix) === null || _a2 === void 0 ? void 0 : _a2.evaluateString(context);
      const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;
      const struct = context.structs.get(type);
      const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);
      if (memberIndex != -1) {
        const value = this.initializer.args[memberIndex].evaluate(context);
        return value;
      }
      console.log(memberIndex);
    }
    return this.initializer.evaluate(context);
  }
};
var LiteralExpr = class extends Expression {
  constructor(value) {
    super();
    this.value = value;
  }
  get astNodeType() {
    return "literalExpr";
  }
  evaluate() {
    return this.value;
  }
};
var BitcastExpr = class extends Expression {
  constructor(type, value) {
    super();
    this.type = type;
    this.value = value;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
};
var TypecastExpr = class extends Expression {
  constructor(type, args) {
    super();
    this.type = type;
    this.args = args;
  }
  get astNodeType() {
    return "typecastExpr";
  }
  evaluate(context) {
    return this.args[0].evaluate(context);
  }
};
var GroupingExpr = class extends Expression {
  constructor(contents) {
    super();
    this.contents = contents;
  }
  get astNodeType() {
    return "groupExpr";
  }
  evaluate(context) {
    return this.contents[0].evaluate(context);
  }
};
var Operator = class extends Expression {
  constructor() {
    super();
  }
};
var UnaryOperator = class extends Operator {
  constructor(operator, right) {
    super();
    this.operator = operator;
    this.right = right;
  }
  get astNodeType() {
    return "unaryOp";
  }
  evaluate(context) {
    switch (this.operator) {
      case "+":
        return this.right.evaluate(context);
      case "-":
        return -this.right.evaluate(context);
      case "!":
        return this.right.evaluate(context) ? 0 : 1;
      case "~":
        return ~this.right.evaluate(context);
      default:
        throw new Error("Unknown unary operator: " + this.operator);
    }
  }
};
var BinaryOperator = class extends Operator {
  constructor(operator, left, right) {
    super();
    this.operator = operator;
    this.left = left;
    this.right = right;
  }
  get astNodeType() {
    return "binaryOp";
  }
  evaluate(context) {
    switch (this.operator) {
      case "+":
        return this.left.evaluate(context) + this.right.evaluate(context);
      case "-":
        return this.left.evaluate(context) - this.right.evaluate(context);
      case "*":
        return this.left.evaluate(context) * this.right.evaluate(context);
      case "/":
        return this.left.evaluate(context) / this.right.evaluate(context);
      case "%":
        return this.left.evaluate(context) % this.right.evaluate(context);
      case "==":
        return this.left.evaluate(context) == this.right.evaluate(context) ? 1 : 0;
      case "!=":
        return this.left.evaluate(context) != this.right.evaluate(context) ? 1 : 0;
      case "<":
        return this.left.evaluate(context) < this.right.evaluate(context) ? 1 : 0;
      case ">":
        return this.left.evaluate(context) > this.right.evaluate(context) ? 1 : 0;
      case "<=":
        return this.left.evaluate(context) <= this.right.evaluate(context) ? 1 : 0;
      case ">=":
        return this.left.evaluate(context) >= this.right.evaluate(context) ? 1 : 0;
      case "&&":
        return this.left.evaluate(context) && this.right.evaluate(context) ? 1 : 0;
      case "||":
        return this.left.evaluate(context) || this.right.evaluate(context) ? 1 : 0;
      default:
        throw new Error(`Unknown operator ${this.operator}`);
    }
  }
};
var SwitchCase = class extends Node {
  constructor() {
    super();
  }
};
var Case = class extends SwitchCase {
  constructor(selector, body) {
    super();
    this.selector = selector;
    this.body = body;
  }
  get astNodeType() {
    return "case";
  }
};
var Default = class extends SwitchCase {
  constructor(body) {
    super();
    this.body = body;
  }
  get astNodeType() {
    return "default";
  }
};
var Argument = class extends Node {
  constructor(name, type, attributes) {
    super();
    this.name = name;
    this.type = type;
    this.attributes = attributes;
  }
  get astNodeType() {
    return "argument";
  }
};
var ElseIf = class extends Node {
  constructor(condition, body) {
    super();
    this.condition = condition;
    this.body = body;
  }
  get astNodeType() {
    return "elseif";
  }
};
var Member = class extends Node {
  constructor(name, type, attributes) {
    super();
    this.name = name;
    this.type = type;
    this.attributes = attributes;
  }
  get astNodeType() {
    return "member";
  }
};
var Attribute = class extends Node {
  constructor(name, value) {
    super();
    this.name = name;
    this.value = value;
  }
  get astNodeType() {
    return "attribute";
  }
};
var _a;
var TokenClass;
(function(TokenClass2) {
  TokenClass2[TokenClass2["token"] = 0] = "token";
  TokenClass2[TokenClass2["keyword"] = 1] = "keyword";
  TokenClass2[TokenClass2["reserved"] = 2] = "reserved";
})(TokenClass || (TokenClass = {}));
var TokenType = class {
  constructor(name, type, rule) {
    this.name = name;
    this.type = type;
    this.rule = rule;
  }
  toString() {
    return this.name;
  }
};
var TokenTypes = class {
};
_a = TokenTypes;
TokenTypes.none = new TokenType("", TokenClass.reserved, "");
TokenTypes.eof = new TokenType("EOF", TokenClass.token, "");
TokenTypes.reserved = {
  asm: new TokenType("asm", TokenClass.reserved, "asm"),
  bf16: new TokenType("bf16", TokenClass.reserved, "bf16"),
  do: new TokenType("do", TokenClass.reserved, "do"),
  enum: new TokenType("enum", TokenClass.reserved, "enum"),
  f16: new TokenType("f16", TokenClass.reserved, "f16"),
  f64: new TokenType("f64", TokenClass.reserved, "f64"),
  handle: new TokenType("handle", TokenClass.reserved, "handle"),
  i8: new TokenType("i8", TokenClass.reserved, "i8"),
  i16: new TokenType("i16", TokenClass.reserved, "i16"),
  i64: new TokenType("i64", TokenClass.reserved, "i64"),
  mat: new TokenType("mat", TokenClass.reserved, "mat"),
  premerge: new TokenType("premerge", TokenClass.reserved, "premerge"),
  regardless: new TokenType("regardless", TokenClass.reserved, "regardless"),
  typedef: new TokenType("typedef", TokenClass.reserved, "typedef"),
  u8: new TokenType("u8", TokenClass.reserved, "u8"),
  u16: new TokenType("u16", TokenClass.reserved, "u16"),
  u64: new TokenType("u64", TokenClass.reserved, "u64"),
  unless: new TokenType("unless", TokenClass.reserved, "unless"),
  using: new TokenType("using", TokenClass.reserved, "using"),
  vec: new TokenType("vec", TokenClass.reserved, "vec"),
  void: new TokenType("void", TokenClass.reserved, "void")
};
TokenTypes.keywords = {
  array: new TokenType("array", TokenClass.keyword, "array"),
  atomic: new TokenType("atomic", TokenClass.keyword, "atomic"),
  bool: new TokenType("bool", TokenClass.keyword, "bool"),
  f32: new TokenType("f32", TokenClass.keyword, "f32"),
  i32: new TokenType("i32", TokenClass.keyword, "i32"),
  mat2x2: new TokenType("mat2x2", TokenClass.keyword, "mat2x2"),
  mat2x3: new TokenType("mat2x3", TokenClass.keyword, "mat2x3"),
  mat2x4: new TokenType("mat2x4", TokenClass.keyword, "mat2x4"),
  mat3x2: new TokenType("mat3x2", TokenClass.keyword, "mat3x2"),
  mat3x3: new TokenType("mat3x3", TokenClass.keyword, "mat3x3"),
  mat3x4: new TokenType("mat3x4", TokenClass.keyword, "mat3x4"),
  mat4x2: new TokenType("mat4x2", TokenClass.keyword, "mat4x2"),
  mat4x3: new TokenType("mat4x3", TokenClass.keyword, "mat4x3"),
  mat4x4: new TokenType("mat4x4", TokenClass.keyword, "mat4x4"),
  ptr: new TokenType("ptr", TokenClass.keyword, "ptr"),
  sampler: new TokenType("sampler", TokenClass.keyword, "sampler"),
  sampler_comparison: new TokenType("sampler_comparison", TokenClass.keyword, "sampler_comparison"),
  struct: new TokenType("struct", TokenClass.keyword, "struct"),
  texture_1d: new TokenType("texture_1d", TokenClass.keyword, "texture_1d"),
  texture_2d: new TokenType("texture_2d", TokenClass.keyword, "texture_2d"),
  texture_2d_array: new TokenType("texture_2d_array", TokenClass.keyword, "texture_2d_array"),
  texture_3d: new TokenType("texture_3d", TokenClass.keyword, "texture_3d"),
  texture_cube: new TokenType("texture_cube", TokenClass.keyword, "texture_cube"),
  texture_cube_array: new TokenType("texture_cube_array", TokenClass.keyword, "texture_cube_array"),
  texture_multisampled_2d: new TokenType("texture_multisampled_2d", TokenClass.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new TokenType("texture_storage_1d", TokenClass.keyword, "texture_storage_1d"),
  texture_storage_2d: new TokenType("texture_storage_2d", TokenClass.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new TokenType("texture_storage_2d_array", TokenClass.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new TokenType("texture_storage_3d", TokenClass.keyword, "texture_storage_3d"),
  texture_depth_2d: new TokenType("texture_depth_2d", TokenClass.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new TokenType("texture_depth_2d_array", TokenClass.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new TokenType("texture_depth_cube", TokenClass.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new TokenType("texture_depth_cube_array", TokenClass.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new TokenType("texture_depth_multisampled_2d", TokenClass.keyword, "texture_depth_multisampled_2d"),
  u32: new TokenType("u32", TokenClass.keyword, "u32"),
  vec2: new TokenType("vec2", TokenClass.keyword, "vec2"),
  vec3: new TokenType("vec3", TokenClass.keyword, "vec3"),
  vec4: new TokenType("vec4", TokenClass.keyword, "vec4"),
  bitcast: new TokenType("bitcast", TokenClass.keyword, "bitcast"),
  block: new TokenType("block", TokenClass.keyword, "block"),
  break: new TokenType("break", TokenClass.keyword, "break"),
  case: new TokenType("case", TokenClass.keyword, "case"),
  continue: new TokenType("continue", TokenClass.keyword, "continue"),
  continuing: new TokenType("continuing", TokenClass.keyword, "continuing"),
  default: new TokenType("default", TokenClass.keyword, "default"),
  discard: new TokenType("discard", TokenClass.keyword, "discard"),
  else: new TokenType("else", TokenClass.keyword, "else"),
  elseif: new TokenType("elseif", TokenClass.keyword, "elseif"),
  enable: new TokenType("enable", TokenClass.keyword, "enable"),
  fallthrough: new TokenType("fallthrough", TokenClass.keyword, "fallthrough"),
  false: new TokenType("false", TokenClass.keyword, "false"),
  fn: new TokenType("fn", TokenClass.keyword, "fn"),
  for: new TokenType("for", TokenClass.keyword, "for"),
  function: new TokenType("function", TokenClass.keyword, "function"),
  if: new TokenType("if", TokenClass.keyword, "if"),
  let: new TokenType("let", TokenClass.keyword, "let"),
  const: new TokenType("const", TokenClass.keyword, "const"),
  loop: new TokenType("loop", TokenClass.keyword, "loop"),
  while: new TokenType("while", TokenClass.keyword, "while"),
  private: new TokenType("private", TokenClass.keyword, "private"),
  read: new TokenType("read", TokenClass.keyword, "read"),
  read_write: new TokenType("read_write", TokenClass.keyword, "read_write"),
  return: new TokenType("return", TokenClass.keyword, "return"),
  storage: new TokenType("storage", TokenClass.keyword, "storage"),
  switch: new TokenType("switch", TokenClass.keyword, "switch"),
  true: new TokenType("true", TokenClass.keyword, "true"),
  alias: new TokenType("alias", TokenClass.keyword, "alias"),
  type: new TokenType("type", TokenClass.keyword, "type"),
  uniform: new TokenType("uniform", TokenClass.keyword, "uniform"),
  var: new TokenType("var", TokenClass.keyword, "var"),
  workgroup: new TokenType("workgroup", TokenClass.keyword, "workgroup"),
  write: new TokenType("write", TokenClass.keyword, "write"),
  r8unorm: new TokenType("r8unorm", TokenClass.keyword, "r8unorm"),
  r8snorm: new TokenType("r8snorm", TokenClass.keyword, "r8snorm"),
  r8uint: new TokenType("r8uint", TokenClass.keyword, "r8uint"),
  r8sint: new TokenType("r8sint", TokenClass.keyword, "r8sint"),
  r16uint: new TokenType("r16uint", TokenClass.keyword, "r16uint"),
  r16sint: new TokenType("r16sint", TokenClass.keyword, "r16sint"),
  r16float: new TokenType("r16float", TokenClass.keyword, "r16float"),
  rg8unorm: new TokenType("rg8unorm", TokenClass.keyword, "rg8unorm"),
  rg8snorm: new TokenType("rg8snorm", TokenClass.keyword, "rg8snorm"),
  rg8uint: new TokenType("rg8uint", TokenClass.keyword, "rg8uint"),
  rg8sint: new TokenType("rg8sint", TokenClass.keyword, "rg8sint"),
  r32uint: new TokenType("r32uint", TokenClass.keyword, "r32uint"),
  r32sint: new TokenType("r32sint", TokenClass.keyword, "r32sint"),
  r32float: new TokenType("r32float", TokenClass.keyword, "r32float"),
  rg16uint: new TokenType("rg16uint", TokenClass.keyword, "rg16uint"),
  rg16sint: new TokenType("rg16sint", TokenClass.keyword, "rg16sint"),
  rg16float: new TokenType("rg16float", TokenClass.keyword, "rg16float"),
  rgba8unorm: new TokenType("rgba8unorm", TokenClass.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new TokenType("rgba8unorm_srgb", TokenClass.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new TokenType("rgba8snorm", TokenClass.keyword, "rgba8snorm"),
  rgba8uint: new TokenType("rgba8uint", TokenClass.keyword, "rgba8uint"),
  rgba8sint: new TokenType("rgba8sint", TokenClass.keyword, "rgba8sint"),
  bgra8unorm: new TokenType("bgra8unorm", TokenClass.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new TokenType("bgra8unorm_srgb", TokenClass.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new TokenType("rgb10a2unorm", TokenClass.keyword, "rgb10a2unorm"),
  rg11b10float: new TokenType("rg11b10float", TokenClass.keyword, "rg11b10float"),
  rg32uint: new TokenType("rg32uint", TokenClass.keyword, "rg32uint"),
  rg32sint: new TokenType("rg32sint", TokenClass.keyword, "rg32sint"),
  rg32float: new TokenType("rg32float", TokenClass.keyword, "rg32float"),
  rgba16uint: new TokenType("rgba16uint", TokenClass.keyword, "rgba16uint"),
  rgba16sint: new TokenType("rgba16sint", TokenClass.keyword, "rgba16sint"),
  rgba16float: new TokenType("rgba16float", TokenClass.keyword, "rgba16float"),
  rgba32uint: new TokenType("rgba32uint", TokenClass.keyword, "rgba32uint"),
  rgba32sint: new TokenType("rgba32sint", TokenClass.keyword, "rgba32sint"),
  rgba32float: new TokenType("rgba32float", TokenClass.keyword, "rgba32float"),
  static_assert: new TokenType("static_assert", TokenClass.keyword, "static_assert")
};
TokenTypes.tokens = {
  decimal_float_literal: new TokenType("decimal_float_literal", TokenClass.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)/),
  hex_float_literal: new TokenType("hex_float_literal", TokenClass.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
  int_literal: new TokenType("int_literal", TokenClass.token, /-?0x[0-9a-fA-F]+|0|-?[1-9][0-9]*/),
  uint_literal: new TokenType("uint_literal", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  ident: new TokenType("ident", TokenClass.token, /[a-zA-Z][0-9a-zA-Z_]*/),
  and: new TokenType("and", TokenClass.token, "&"),
  and_and: new TokenType("and_and", TokenClass.token, "&&"),
  arrow: new TokenType("arrow ", TokenClass.token, "->"),
  attr: new TokenType("attr", TokenClass.token, "@"),
  attr_left: new TokenType("attr_left", TokenClass.token, "[["),
  attr_right: new TokenType("attr_right", TokenClass.token, "]]"),
  forward_slash: new TokenType("forward_slash", TokenClass.token, "/"),
  bang: new TokenType("bang", TokenClass.token, "!"),
  bracket_left: new TokenType("bracket_left", TokenClass.token, "["),
  bracket_right: new TokenType("bracket_right", TokenClass.token, "]"),
  brace_left: new TokenType("brace_left", TokenClass.token, "{"),
  brace_right: new TokenType("brace_right", TokenClass.token, "}"),
  colon: new TokenType("colon", TokenClass.token, ":"),
  comma: new TokenType("comma", TokenClass.token, ","),
  equal: new TokenType("equal", TokenClass.token, "="),
  equal_equal: new TokenType("equal_equal", TokenClass.token, "=="),
  not_equal: new TokenType("not_equal", TokenClass.token, "!="),
  greater_than: new TokenType("greater_than", TokenClass.token, ">"),
  greater_than_equal: new TokenType("greater_than_equal", TokenClass.token, ">="),
  shift_right: new TokenType("shift_right", TokenClass.token, ">>"),
  less_than: new TokenType("less_than", TokenClass.token, "<"),
  less_than_equal: new TokenType("less_than_equal", TokenClass.token, "<="),
  shift_left: new TokenType("shift_left", TokenClass.token, "<<"),
  modulo: new TokenType("modulo", TokenClass.token, "%"),
  minus: new TokenType("minus", TokenClass.token, "-"),
  minus_minus: new TokenType("minus_minus", TokenClass.token, "--"),
  period: new TokenType("period", TokenClass.token, "."),
  plus: new TokenType("plus", TokenClass.token, "+"),
  plus_plus: new TokenType("plus_plus", TokenClass.token, "++"),
  or: new TokenType("or", TokenClass.token, "|"),
  or_or: new TokenType("or_or", TokenClass.token, "||"),
  paren_left: new TokenType("paren_left", TokenClass.token, "("),
  paren_right: new TokenType("paren_right", TokenClass.token, ")"),
  semicolon: new TokenType("semicolon", TokenClass.token, ";"),
  star: new TokenType("star", TokenClass.token, "*"),
  tilde: new TokenType("tilde", TokenClass.token, "~"),
  underscore: new TokenType("underscore", TokenClass.token, "_"),
  xor: new TokenType("xor", TokenClass.token, "^"),
  plus_equal: new TokenType("plus_equal", TokenClass.token, "+="),
  minus_equal: new TokenType("minus_equal", TokenClass.token, "-="),
  times_equal: new TokenType("times_equal", TokenClass.token, "*="),
  division_equal: new TokenType("division_equal", TokenClass.token, "/="),
  modulo_equal: new TokenType("modulo_equal", TokenClass.token, "%="),
  and_equal: new TokenType("and_equal", TokenClass.token, "&="),
  or_equal: new TokenType("or_equal", TokenClass.token, "|="),
  xor_equal: new TokenType("xor_equal", TokenClass.token, "^="),
  shift_right_equal: new TokenType("shift_right_equal", TokenClass.token, ">>="),
  shift_left_equal: new TokenType("shift_left_equal", TokenClass.token, "<<=")
};
TokenTypes.storage_class = [
  _a.keywords.function,
  _a.keywords.private,
  _a.keywords.workgroup,
  _a.keywords.uniform,
  _a.keywords.storage
];
TokenTypes.access_mode = [
  _a.keywords.read,
  _a.keywords.write,
  _a.keywords.read_write
];
TokenTypes.sampler_type = [
  _a.keywords.sampler,
  _a.keywords.sampler_comparison
];
TokenTypes.sampled_texture_type = [
  _a.keywords.texture_1d,
  _a.keywords.texture_2d,
  _a.keywords.texture_2d_array,
  _a.keywords.texture_3d,
  _a.keywords.texture_cube,
  _a.keywords.texture_cube_array
];
TokenTypes.multisampled_texture_type = [
  _a.keywords.texture_multisampled_2d
];
TokenTypes.storage_texture_type = [
  _a.keywords.texture_storage_1d,
  _a.keywords.texture_storage_2d,
  _a.keywords.texture_storage_2d_array,
  _a.keywords.texture_storage_3d
];
TokenTypes.depth_texture_type = [
  _a.keywords.texture_depth_2d,
  _a.keywords.texture_depth_2d_array,
  _a.keywords.texture_depth_cube,
  _a.keywords.texture_depth_cube_array,
  _a.keywords.texture_depth_multisampled_2d
];
TokenTypes.any_texture_type = [
  ..._a.sampled_texture_type,
  ..._a.multisampled_texture_type,
  ..._a.storage_texture_type,
  ..._a.depth_texture_type
];
TokenTypes.texel_format = [
  _a.keywords.r8unorm,
  _a.keywords.r8snorm,
  _a.keywords.r8uint,
  _a.keywords.r8sint,
  _a.keywords.r16uint,
  _a.keywords.r16sint,
  _a.keywords.r16float,
  _a.keywords.rg8unorm,
  _a.keywords.rg8snorm,
  _a.keywords.rg8uint,
  _a.keywords.rg8sint,
  _a.keywords.r32uint,
  _a.keywords.r32sint,
  _a.keywords.r32float,
  _a.keywords.rg16uint,
  _a.keywords.rg16sint,
  _a.keywords.rg16float,
  _a.keywords.rgba8unorm,
  _a.keywords.rgba8unorm_srgb,
  _a.keywords.rgba8snorm,
  _a.keywords.rgba8uint,
  _a.keywords.rgba8sint,
  _a.keywords.bgra8unorm,
  _a.keywords.bgra8unorm_srgb,
  _a.keywords.rgb10a2unorm,
  _a.keywords.rg11b10float,
  _a.keywords.rg32uint,
  _a.keywords.rg32sint,
  _a.keywords.rg32float,
  _a.keywords.rgba16uint,
  _a.keywords.rgba16sint,
  _a.keywords.rgba16float,
  _a.keywords.rgba32uint,
  _a.keywords.rgba32sint,
  _a.keywords.rgba32float
];
TokenTypes.const_literal = [
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.decimal_float_literal,
  _a.tokens.hex_float_literal,
  _a.keywords.true,
  _a.keywords.false
];
TokenTypes.literal_or_ident = [
  _a.tokens.ident,
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.decimal_float_literal,
  _a.tokens.hex_float_literal
];
TokenTypes.element_count_expression = [
  _a.tokens.int_literal,
  _a.tokens.uint_literal,
  _a.tokens.ident
];
TokenTypes.template_types = [
  _a.keywords.vec2,
  _a.keywords.vec3,
  _a.keywords.vec4,
  _a.keywords.mat2x2,
  _a.keywords.mat2x3,
  _a.keywords.mat2x4,
  _a.keywords.mat3x2,
  _a.keywords.mat3x3,
  _a.keywords.mat3x4,
  _a.keywords.mat4x2,
  _a.keywords.mat4x3,
  _a.keywords.mat4x4,
  _a.keywords.atomic,
  _a.keywords.bitcast,
  ..._a.any_texture_type
];
TokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block];
TokenTypes.assignment_operators = [
  _a.tokens.equal,
  _a.tokens.plus_equal,
  _a.tokens.minus_equal,
  _a.tokens.times_equal,
  _a.tokens.division_equal,
  _a.tokens.modulo_equal,
  _a.tokens.and_equal,
  _a.tokens.or_equal,
  _a.tokens.xor_equal,
  _a.tokens.shift_right_equal,
  _a.tokens.shift_left_equal
];
TokenTypes.increment_operators = [
  _a.tokens.plus_plus,
  _a.tokens.minus_minus
];
var Token = class {
  constructor(type, lexeme, line) {
    this.type = type;
    this.lexeme = lexeme;
    this.line = line;
  }
  toString() {
    return this.lexeme;
  }
};
var WgslScanner = class {
  constructor(source) {
    this._tokens = [];
    this._start = 0;
    this._current = 0;
    this._line = 1;
    this._source = source !== null && source !== void 0 ? source : "";
  }
  scanTokens() {
    while (!this._isAtEnd()) {
      this._start = this._current;
      if (!this.scanToken())
        throw `Invalid syntax at line ${this._line}`;
    }
    this._tokens.push(new Token(TokenTypes.eof, "", this._line));
    return this._tokens;
  }
  scanToken() {
    let lexeme = this._advance();
    if (lexeme == "\n") {
      this._line++;
      return true;
    }
    if (this._isWhitespace(lexeme)) {
      return true;
    }
    if (lexeme == "/") {
      if (this._peekAhead() == "/") {
        while (lexeme != "\n") {
          if (this._isAtEnd())
            return true;
          lexeme = this._advance();
        }
        this._line++;
        return true;
      } else if (this._peekAhead() == "*") {
        this._advance();
        let commentLevel = 1;
        while (commentLevel > 0) {
          if (this._isAtEnd())
            return true;
          lexeme = this._advance();
          if (lexeme == "\n") {
            this._line++;
          } else if (lexeme == "*") {
            if (this._peekAhead() == "/") {
              this._advance();
              commentLevel--;
              if (commentLevel == 0) {
                return true;
              }
            }
          } else if (lexeme == "/") {
            if (this._peekAhead() == "*") {
              this._advance();
              commentLevel++;
            }
          }
        }
        return true;
      }
    }
    let matchType = TokenTypes.none;
    for (; ; ) {
      let matchedType = this._findType(lexeme);
      if (lexeme == ">" && this._peekAhead() == ">") {
        let foundLessThan = false;
        let ti = this._tokens.length - 1;
        for (let count = 0; count < 4 && ti >= 0; ++count, --ti) {
          if (this._tokens[ti].type === TokenTypes.tokens.less_than) {
            if (ti > 0 && TokenTypes.template_types.indexOf(this._tokens[ti - 1].type) != -1) {
              foundLessThan = true;
            }
            break;
          }
        }
        if (foundLessThan) {
          this._addToken(matchedType);
          return true;
        }
      }
      if (matchedType === TokenTypes.none) {
        let lookAheadLexeme = lexeme;
        let lookAhead = 0;
        const maxLookAhead = 2;
        for (let li = 0; li < maxLookAhead; ++li) {
          lookAheadLexeme += this._peekAhead(li);
          matchedType = this._findType(lookAheadLexeme);
          if (matchedType !== TokenTypes.none) {
            lookAhead = li;
            break;
          }
        }
        if (matchedType === TokenTypes.none) {
          if (matchType === TokenTypes.none)
            return false;
          this._current--;
          this._addToken(matchType);
          return true;
        }
        lexeme = lookAheadLexeme;
        this._current += lookAhead + 1;
      }
      matchType = matchedType;
      if (this._isAtEnd())
        break;
      lexeme += this._advance();
    }
    if (matchType === TokenTypes.none)
      return false;
    this._addToken(matchType);
    return true;
  }
  _findType(lexeme) {
    for (const name in TokenTypes.keywords) {
      const type = TokenTypes.keywords[name];
      if (this._match(lexeme, type.rule)) {
        return type;
      }
    }
    for (const name in TokenTypes.tokens) {
      const type = TokenTypes.tokens[name];
      if (this._match(lexeme, type.rule)) {
        return type;
      }
    }
    return TokenTypes.none;
  }
  _match(lexeme, rule) {
    if (typeof rule === "string") {
      if (rule == lexeme) {
        return true;
      }
    } else {
      const match = rule.exec(lexeme);
      if (match && match.index == 0 && match[0] == lexeme)
        return true;
    }
    return false;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isWhitespace(c) {
    return c == " " || c == "	" || c == "\r";
  }
  _advance(amount = 0) {
    let c = this._source[this._current];
    amount = amount || 0;
    amount++;
    this._current += amount;
    return c;
  }
  _peekAhead(offset = 0) {
    offset = offset || 0;
    if (this._current + offset >= this._source.length)
      return "\0";
    return this._source[this._current + offset];
  }
  _addToken(type) {
    const text = this._source.substring(this._start, this._current);
    this._tokens.push(new Token(type, text, this._line));
  }
};
var WgslParser = class {
  constructor() {
    this._tokens = [];
    this._current = 0;
    this._context = new ParseContext();
  }
  parse(tokensOrCode) {
    this._initialize(tokensOrCode);
    let statements = [];
    while (!this._isAtEnd()) {
      const statement = this._global_decl_or_directive();
      if (!statement)
        break;
      statements.push(statement);
    }
    return statements;
  }
  _initialize(tokensOrCode) {
    if (tokensOrCode) {
      if (typeof tokensOrCode == "string") {
        const scanner = new WgslScanner(tokensOrCode);
        this._tokens = scanner.scanTokens();
      } else {
        this._tokens = tokensOrCode;
      }
    } else {
      this._tokens = [];
    }
    this._current = 0;
  }
  _error(token, message) {
    console.error(token, message);
    return {
      token,
      message,
      toString: function() {
        return `${message}`;
      }
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == TokenTypes.eof;
  }
  _match(types) {
    if (types instanceof TokenType) {
      if (this._check(types)) {
        this._advance();
        return true;
      }
      return false;
    }
    for (let i = 0, l = types.length; i < l; ++i) {
      const type = types[i];
      if (this._check(type)) {
        this._advance();
        return true;
      }
    }
    return false;
  }
  _consume(types, message) {
    if (this._check(types))
      return this._advance();
    throw this._error(this._peek(), message);
  }
  _check(types) {
    if (this._isAtEnd())
      return false;
    const tk = this._peek();
    if (types instanceof Array) {
      let t = tk.type;
      let index = types.indexOf(t);
      return index != -1;
    }
    return tk.type == types;
  }
  _advance() {
    if (!this._isAtEnd())
      this._current++;
    return this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
      ;
    if (this._match(TokenTypes.keywords.alias)) {
      const type = this._type_alias();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return type;
    }
    if (this._match(TokenTypes.keywords.enable)) {
      const enable = this._enable_directive();
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return enable;
    }
    const attrs = this._attribute();
    if (this._check(TokenTypes.keywords.var)) {
      const _var = this._global_variable_decl();
      if (_var != null)
        _var.attributes = attrs;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _var;
    }
    if (this._check(TokenTypes.keywords.let)) {
      const _let = this._global_let_decl();
      if (_let != null)
        _let.attributes = attrs;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _let;
    }
    if (this._check(TokenTypes.keywords.const)) {
      const _const = this._global_const_decl();
      if (_const != null)
        _const.attributes = attrs;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      return _const;
    }
    if (this._check(TokenTypes.keywords.struct)) {
      const _struct = this._struct_decl();
      if (_struct != null)
        _struct.attributes = attrs;
      return _struct;
    }
    if (this._check(TokenTypes.keywords.fn)) {
      const _fn = this._function_decl();
      if (_fn != null)
        _fn.attributes = attrs;
      return _fn;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(TokenTypes.keywords.fn))
      return null;
    const name = this._consume(TokenTypes.tokens.ident, "Expected function name.").toString();
    this._consume(TokenTypes.tokens.paren_left, "Expected '(' for function arguments.");
    const args = [];
    if (!this._check(TokenTypes.tokens.paren_right)) {
      do {
        if (this._check(TokenTypes.tokens.paren_right))
          break;
        const argAttrs = this._attribute();
        const name2 = this._consume(TokenTypes.tokens.ident, "Expected argument name.").toString();
        this._consume(TokenTypes.tokens.colon, "Expected ':' for argument type.");
        const typeAttrs = this._attribute();
        const type = this._type_decl();
        if (type != null) {
          type.attributes = typeAttrs;
          args.push(new Argument(name2, type, argAttrs));
        }
      } while (this._match(TokenTypes.tokens.comma));
    }
    this._consume(TokenTypes.tokens.paren_right, "Expected ')' after function arguments.");
    let _return = null;
    if (this._match(TokenTypes.tokens.arrow)) {
      const attrs = this._attribute();
      _return = this._type_decl();
      if (_return != null)
        _return.attributes = attrs;
    }
    const body = this._compound_statement();
    return new Function(name, args, _return, body);
  }
  _compound_statement() {
    const statements = [];
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for block.");
    while (!this._check(TokenTypes.tokens.brace_right)) {
      const statement = this._statement();
      if (statement !== null)
        statements.push(statement);
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for block.");
    return statements;
  }
  _statement() {
    while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
      ;
    if (this._check(TokenTypes.keywords.if))
      return this._if_statement();
    if (this._check(TokenTypes.keywords.switch))
      return this._switch_statement();
    if (this._check(TokenTypes.keywords.loop))
      return this._loop_statement();
    if (this._check(TokenTypes.keywords.for))
      return this._for_statement();
    if (this._check(TokenTypes.keywords.while))
      return this._while_statement();
    if (this._check(TokenTypes.keywords.static_assert))
      return this._static_assert_statement();
    if (this._check(TokenTypes.tokens.brace_left))
      return this._compound_statement();
    let result = null;
    if (this._check(TokenTypes.keywords.return))
      result = this._return_statement();
    else if (this._check([
      TokenTypes.keywords.var,
      TokenTypes.keywords.let,
      TokenTypes.keywords.const
    ]))
      result = this._variable_statement();
    else if (this._match(TokenTypes.keywords.discard))
      result = new Discard();
    else if (this._match(TokenTypes.keywords.break))
      result = new Break();
    else if (this._match(TokenTypes.keywords.continue))
      result = new Continue();
    else
      result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    if (result != null)
      this._consume(TokenTypes.tokens.semicolon, "Expected ';' after statement.");
    return result;
  }
  _static_assert_statement() {
    if (!this._match(TokenTypes.keywords.static_assert))
      return null;
    let expression = this._optional_paren_expression();
    return new StaticAssert(expression);
  }
  _while_statement() {
    if (!this._match(TokenTypes.keywords.while))
      return null;
    let condition = this._optional_paren_expression();
    const block = this._compound_statement();
    return new While(condition, block);
  }
  _for_statement() {
    if (!this._match(TokenTypes.keywords.for))
      return null;
    this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
    const init = !this._check(TokenTypes.tokens.semicolon) ? this._for_init() : null;
    this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
    const condition = !this._check(TokenTypes.tokens.semicolon) ? this._short_circuit_or_expression() : null;
    this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
    const increment = !this._check(TokenTypes.tokens.paren_right) ? this._for_increment() : null;
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
    const body = this._compound_statement();
    return new For(init, condition, increment, body);
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(TokenTypes.keywords.var)) {
      const _var = this._variable_decl();
      if (_var === null)
        throw this._error(this._peek(), "Variable declaration expected.");
      let value = null;
      if (this._match(TokenTypes.tokens.equal))
        value = this._short_circuit_or_expression();
      return new Var(_var.name, _var.type, _var.storage, _var.access, value);
    }
    if (this._match(TokenTypes.keywords.let)) {
      const name = this._consume(TokenTypes.tokens.ident, "Expected name for let.").toString();
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const typeAttrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = typeAttrs;
      }
      this._consume(TokenTypes.tokens.equal, "Expected '=' for let.");
      const value = this._short_circuit_or_expression();
      return new Let(name, type, null, null, value);
    }
    if (this._match(TokenTypes.keywords.const)) {
      const name = this._consume(TokenTypes.tokens.ident, "Expected name for const.").toString();
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const typeAttrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = typeAttrs;
      }
      this._consume(TokenTypes.tokens.equal, "Expected '=' for const.");
      const value = this._short_circuit_or_expression();
      return new Const(name, type, null, null, value);
    }
    return null;
  }
  _increment_decrement_statement() {
    const savedPos = this._current;
    const _var = this._unary_expression();
    if (_var == null)
      return null;
    if (!this._check(TokenTypes.increment_operators)) {
      this._current = savedPos;
      return null;
    }
    const token = this._consume(TokenTypes.increment_operators, "Expected increment operator");
    return new Increment(token.type === TokenTypes.tokens.plus_plus ? IncrementOperator.increment : IncrementOperator.decrement, _var);
  }
  _assignment_statement() {
    let _var = null;
    if (this._check(TokenTypes.tokens.brace_right))
      return null;
    let isUnderscore = this._match(TokenTypes.tokens.underscore);
    if (!isUnderscore)
      _var = this._unary_expression();
    if (!isUnderscore && _var == null)
      return null;
    const type = this._consume(TokenTypes.assignment_operators, "Expected assignment operator.");
    const value = this._short_circuit_or_expression();
    return new Assign(AssignOperator.parse(type.lexeme), _var, value);
  }
  _func_call_statement() {
    if (!this._check(TokenTypes.tokens.ident))
      return null;
    const savedPos = this._current;
    const name = this._consume(TokenTypes.tokens.ident, "Expected function name.");
    const args = this._argument_expression_list();
    if (args === null) {
      this._current = savedPos;
      return null;
    }
    return new Call(name.lexeme, args);
  }
  _loop_statement() {
    if (!this._match(TokenTypes.keywords.loop))
      return null;
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for loop.");
    const statements = [];
    let statement = this._statement();
    while (statement !== null) {
      if (statement instanceof Array) {
        for (let s of statement) {
          statements.push(s);
        }
      } else {
        statements.push(statement);
      }
      statement = this._statement();
    }
    let continuing = null;
    if (this._match(TokenTypes.keywords.continuing))
      continuing = this._compound_statement();
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for loop.");
    return new Loop(statements, continuing);
  }
  _switch_statement() {
    if (!this._match(TokenTypes.keywords.switch))
      return null;
    const condition = this._optional_paren_expression();
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for switch.");
    const body = this._switch_body();
    if (body == null || body.length == 0)
      throw this._error(this._previous(), "Expected 'case' or 'default'.");
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' for switch.");
    return new Switch(condition, body);
  }
  _switch_body() {
    const cases = [];
    if (this._match(TokenTypes.keywords.case)) {
      const selector = this._case_selectors();
      this._consume(TokenTypes.tokens.colon, "Exected ':' for switch case.");
      this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch case.");
      const body = this._case_body();
      this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch case.");
      cases.push(new Case(selector, body));
    }
    if (this._match(TokenTypes.keywords.default)) {
      this._consume(TokenTypes.tokens.colon, "Exected ':' for switch default.");
      this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch default.");
      const body = this._case_body();
      this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch default.");
      cases.push(new Default(body));
    }
    if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {
      const _cases = this._switch_body();
      cases.push(_cases[0]);
    }
    return cases;
  }
  _case_selectors() {
    const selectors = [
      this._consume(TokenTypes.const_literal, "Expected constant literal").toString()
    ];
    while (this._match(TokenTypes.tokens.comma)) {
      selectors.push(this._consume(TokenTypes.const_literal, "Expected constant literal").toString());
    }
    return selectors;
  }
  _case_body() {
    if (this._match(TokenTypes.keywords.fallthrough)) {
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
      return [];
    }
    let statement = this._statement();
    if (statement == null)
      return [];
    if (!(statement instanceof Array)) {
      statement = [statement];
    }
    const nextStatement = this._case_body();
    if (nextStatement.length == 0)
      return statement;
    return [...statement, nextStatement[0]];
  }
  _if_statement() {
    if (!this._match(TokenTypes.keywords.if))
      return null;
    const condition = this._optional_paren_expression();
    const block = this._compound_statement();
    let elseif = null;
    if (this._match(TokenTypes.keywords.elseif))
      elseif = this._elseif_statement();
    let _else = null;
    if (this._match(TokenTypes.keywords.else))
      _else = this._compound_statement();
    return new If(condition, block, elseif, _else);
  }
  _elseif_statement() {
    const elseif = [];
    const condition = this._optional_paren_expression();
    const block = this._compound_statement();
    elseif.push(new ElseIf(condition, block));
    if (this._match(TokenTypes.keywords.elseif))
      elseif.push(this._elseif_statement()[0]);
    return elseif;
  }
  _return_statement() {
    if (!this._match(TokenTypes.keywords.return))
      return null;
    const value = this._short_circuit_or_expression();
    return new Return(value);
  }
  _short_circuit_or_expression() {
    let expr = this._short_circuit_and_expr();
    while (this._match(TokenTypes.tokens.or_or)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());
    }
    return expr;
  }
  _short_circuit_and_expr() {
    let expr = this._inclusive_or_expression();
    while (this._match(TokenTypes.tokens.and_and)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());
    }
    return expr;
  }
  _inclusive_or_expression() {
    let expr = this._exclusive_or_expression();
    while (this._match(TokenTypes.tokens.or)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());
    }
    return expr;
  }
  _exclusive_or_expression() {
    let expr = this._and_expression();
    while (this._match(TokenTypes.tokens.xor)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());
    }
    return expr;
  }
  _and_expression() {
    let expr = this._equality_expression();
    while (this._match(TokenTypes.tokens.and)) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());
    }
    return expr;
  }
  _equality_expression() {
    const expr = this._relational_expression();
    if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {
      return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());
    }
    return expr;
  }
  _relational_expression() {
    let expr = this._shift_expression();
    while (this._match([
      TokenTypes.tokens.less_than,
      TokenTypes.tokens.greater_than,
      TokenTypes.tokens.less_than_equal,
      TokenTypes.tokens.greater_than_equal
    ])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());
    }
    return expr;
  }
  _shift_expression() {
    let expr = this._additive_expression();
    while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());
    }
    return expr;
  }
  _additive_expression() {
    let expr = this._multiplicative_expression();
    while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());
    }
    return expr;
  }
  _multiplicative_expression() {
    let expr = this._unary_expression();
    while (this._match([
      TokenTypes.tokens.star,
      TokenTypes.tokens.forward_slash,
      TokenTypes.tokens.modulo
    ])) {
      expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());
    }
    return expr;
  }
  _unary_expression() {
    if (this._match([
      TokenTypes.tokens.minus,
      TokenTypes.tokens.bang,
      TokenTypes.tokens.tilde,
      TokenTypes.tokens.star,
      TokenTypes.tokens.and
    ])) {
      return new UnaryOperator(this._previous().toString(), this._unary_expression());
    }
    return this._singular_expression();
  }
  _singular_expression() {
    const expr = this._primary_expression();
    const p = this._postfix_expression();
    if (p)
      expr.postfix = p;
    return expr;
  }
  _postfix_expression() {
    if (this._match(TokenTypes.tokens.bracket_left)) {
      const expr = this._short_circuit_or_expression();
      this._consume(TokenTypes.tokens.bracket_right, "Expected ']'.");
      const p = this._postfix_expression();
      if (p)
        expr.postfix = p;
      return expr;
    }
    if (this._match(TokenTypes.tokens.period)) {
      const name = this._consume(TokenTypes.tokens.ident, "Expected member name.");
      const p = this._postfix_expression();
      const expr = new StringExpr(name.lexeme);
      if (p)
        expr.postfix = p;
      return expr;
    }
    return null;
  }
  _getStruct(name) {
    if (this._context.aliases.has(name)) {
      const alias = this._context.aliases.get(name).type;
      return alias;
    }
    if (this._context.structs.has(name)) {
      const struct = this._context.structs.get(name);
      return struct;
    }
    return null;
  }
  _primary_expression() {
    if (this._match(TokenTypes.tokens.ident)) {
      const name = this._previous().toString();
      if (this._check(TokenTypes.tokens.paren_left)) {
        const args2 = this._argument_expression_list();
        const struct = this._getStruct(name);
        if (struct != null) {
          return new CreateExpr(struct, args2);
        }
        return new CallExpr(name, args2);
      }
      if (this._context.constants.has(name)) {
        const c = this._context.constants.get(name);
        return new ConstExpr(name, c.value);
      }
      return new VariableExpr(name);
    }
    if (this._match(TokenTypes.const_literal)) {
      return new LiteralExpr(parseFloat(this._previous().toString()));
    }
    if (this._check(TokenTypes.tokens.paren_left)) {
      return this._paren_expression();
    }
    if (this._match(TokenTypes.keywords.bitcast)) {
      this._consume(TokenTypes.tokens.less_than, "Expected '<'.");
      const type2 = this._type_decl();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
      const value = this._paren_expression();
      return new BitcastExpr(type2, value);
    }
    const type = this._type_decl();
    const args = this._argument_expression_list();
    return new TypecastExpr(type, args);
  }
  _argument_expression_list() {
    if (!this._match(TokenTypes.tokens.paren_left))
      return null;
    const args = [];
    do {
      if (this._check(TokenTypes.tokens.paren_right))
        break;
      const arg = this._short_circuit_or_expression();
      args.push(arg);
    } while (this._match(TokenTypes.tokens.comma));
    this._consume(TokenTypes.tokens.paren_right, "Expected ')' for agument list");
    return args;
  }
  _optional_paren_expression() {
    this._match(TokenTypes.tokens.paren_left);
    const expr = this._short_circuit_or_expression();
    this._match(TokenTypes.tokens.paren_right);
    return new GroupingExpr([expr]);
  }
  _paren_expression() {
    this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
    const expr = this._short_circuit_or_expression();
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
    return new GroupingExpr([expr]);
  }
  _struct_decl() {
    if (!this._match(TokenTypes.keywords.struct))
      return null;
    const name = this._consume(TokenTypes.tokens.ident, "Expected name for struct.").toString();
    this._consume(TokenTypes.tokens.brace_left, "Expected '{' for struct body.");
    const members = [];
    while (!this._check(TokenTypes.tokens.brace_right)) {
      const memberAttrs = this._attribute();
      const memberName = this._consume(TokenTypes.tokens.ident, "Expected variable name.").toString();
      this._consume(TokenTypes.tokens.colon, "Expected ':' for struct member type.");
      const typeAttrs = this._attribute();
      const memberType = this._type_decl();
      if (memberType != null)
        memberType.attributes = typeAttrs;
      if (!this._check(TokenTypes.tokens.brace_right))
        this._consume(TokenTypes.tokens.comma, "Expected ',' for struct member.");
      else
        this._match(TokenTypes.tokens.comma);
      members.push(new Member(memberName, memberType, memberAttrs));
    }
    this._consume(TokenTypes.tokens.brace_right, "Expected '}' after struct body.");
    const structNode = new Struct(name, members);
    this._context.structs.set(name, structNode);
    return structNode;
  }
  _global_variable_decl() {
    const _var = this._variable_decl();
    if (_var && this._match(TokenTypes.tokens.equal))
      _var.value = this._const_expression();
    return _var;
  }
  _global_const_decl() {
    if (!this._match(TokenTypes.keywords.const))
      return null;
    const name = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null)
        type.attributes = attrs;
    }
    let value = null;
    if (this._match(TokenTypes.tokens.equal)) {
      let valueExpr = this._short_circuit_or_expression();
      if (valueExpr instanceof CreateExpr) {
        value = valueExpr;
      } else if (valueExpr instanceof ConstExpr && valueExpr.initializer instanceof CreateExpr) {
        value = valueExpr.initializer;
      } else {
        let constValue = valueExpr.evaluate(this._context);
        value = new LiteralExpr(constValue);
      }
    }
    const c = new Const(name.toString(), type, "", "", value);
    this._context.constants.set(c.name, c);
    return c;
  }
  _global_let_decl() {
    if (!this._match(TokenTypes.keywords.let))
      return null;
    const name = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null)
        type.attributes = attrs;
    }
    let value = null;
    if (this._match(TokenTypes.tokens.equal)) {
      value = this._const_expression();
    }
    return new Let(name.toString(), type, "", "", value);
  }
  _const_expression() {
    if (this._match(TokenTypes.const_literal))
      return new StringExpr(this._previous().toString());
    const type = this._type_decl();
    this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
    let args = [];
    while (!this._check(TokenTypes.tokens.paren_right)) {
      args.push(this._const_expression());
      if (!this._check(TokenTypes.tokens.comma))
        break;
      this._advance();
    }
    this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
    return new CreateExpr(type, args);
  }
  _variable_decl() {
    if (!this._match(TokenTypes.keywords.var))
      return null;
    let storage = "";
    let access = "";
    if (this._match(TokenTypes.tokens.less_than)) {
      storage = this._consume(TokenTypes.storage_class, "Expected storage_class.").toString();
      if (this._match(TokenTypes.tokens.comma))
        access = this._consume(TokenTypes.access_mode, "Expected access_mode.").toString();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
    }
    const name = this._consume(TokenTypes.tokens.ident, "Expected variable name");
    let type = null;
    if (this._match(TokenTypes.tokens.colon)) {
      const attrs = this._attribute();
      type = this._type_decl();
      if (type != null)
        type.attributes = attrs;
    }
    return new Var(name.toString(), type, storage, access, null);
  }
  _enable_directive() {
    const name = this._consume(TokenTypes.tokens.ident, "identity expected.");
    return new Enable(name.toString());
  }
  _type_alias() {
    const name = this._consume(TokenTypes.tokens.ident, "identity expected.");
    this._consume(TokenTypes.tokens.equal, "Expected '=' for type alias.");
    let aliasType = this._type_decl();
    if (aliasType === null) {
      throw this._error(this._peek(), "Expected Type for Alias.");
    }
    if (this._context.aliases.has(aliasType.name)) {
      aliasType = this._context.aliases.get(aliasType.name).type;
    }
    const aliasNode = new Alias(name.toString(), aliasType);
    this._context.aliases.set(aliasNode.name, aliasNode);
    return aliasNode;
  }
  _type_decl() {
    if (this._check([
      TokenTypes.tokens.ident,
      ...TokenTypes.texel_format,
      TokenTypes.keywords.bool,
      TokenTypes.keywords.f32,
      TokenTypes.keywords.i32,
      TokenTypes.keywords.u32
    ])) {
      const type2 = this._advance();
      return new Type(type2.toString());
    }
    if (this._check(TokenTypes.template_types)) {
      let type2 = this._advance().toString();
      let format = null;
      let access = null;
      if (this._match(TokenTypes.tokens.less_than)) {
        format = this._type_decl();
        access = null;
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for type.");
      }
      return new TemplateType(type2, format, access);
    }
    if (this._match(TokenTypes.keywords.ptr)) {
      let pointer = this._previous().toString();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for pointer.");
      const storage = this._consume(TokenTypes.storage_class, "Expected storage_class for pointer");
      this._consume(TokenTypes.tokens.comma, "Expected ',' for pointer.");
      const decl = this._type_decl();
      let access = null;
      if (this._match(TokenTypes.tokens.comma))
        access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for pointer.");
      return new PointerType(pointer, storage.toString(), decl, access);
    }
    let type = this._texture_sampler_types();
    if (type)
      return type;
    const attrs = this._attribute();
    if (this._match(TokenTypes.keywords.array)) {
      let format = null;
      let countInt = -1;
      const array = this._previous();
      if (this._match(TokenTypes.tokens.less_than)) {
        format = this._type_decl();
        if (this._context.aliases.has(format.name)) {
          format = this._context.aliases.get(format.name).type;
        }
        let count = "";
        if (this._match(TokenTypes.tokens.comma)) {
          let c = this._shift_expression();
          count = c.evaluate(this._context).toString();
        }
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for array.");
        countInt = count ? parseInt(count) : 0;
      }
      return new ArrayType(array.toString(), attrs, format, countInt);
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(TokenTypes.sampler_type))
      return new SamplerType(this._previous().toString(), null, null);
    if (this._match(TokenTypes.depth_texture_type))
      return new SamplerType(this._previous().toString(), null, null);
    if (this._match(TokenTypes.sampled_texture_type) || this._match(TokenTypes.multisampled_texture_type)) {
      const sampler = this._previous();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
      const format = this._type_decl();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
      return new SamplerType(sampler.toString(), format, null);
    }
    if (this._match(TokenTypes.storage_texture_type)) {
      const sampler = this._previous();
      this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
      const format = this._consume(TokenTypes.texel_format, "Invalid texel format.").toString();
      this._consume(TokenTypes.tokens.comma, "Expected ',' after texel format.");
      const access = this._consume(TokenTypes.access_mode, "Expected access mode for storage texture type.").toString();
      this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
      return new SamplerType(sampler.toString(), format, access);
    }
    return null;
  }
  _attribute() {
    let attributes = [];
    while (this._match(TokenTypes.tokens.attr)) {
      const name = this._consume(TokenTypes.attribute_name, "Expected attribute name");
      const attr = new Attribute(name.toString(), null);
      if (this._match(TokenTypes.tokens.paren_left)) {
        attr.value = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
        if (this._check(TokenTypes.tokens.comma)) {
          this._advance();
          do {
            const v = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
            if (!(attr.value instanceof Array)) {
              attr.value = [attr.value];
            }
            attr.value.push(v);
          } while (this._match(TokenTypes.tokens.comma));
        }
        this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
      }
      attributes.push(attr);
    }
    while (this._match(TokenTypes.tokens.attr_left)) {
      if (!this._check(TokenTypes.tokens.attr_right)) {
        do {
          const name = this._consume(TokenTypes.attribute_name, "Expected attribute name");
          const attr = new Attribute(name.toString(), null);
          if (this._match(TokenTypes.tokens.paren_left)) {
            attr.value = [
              this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString()
            ];
            if (this._check(TokenTypes.tokens.comma)) {
              this._advance();
              do {
                const v = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
                attr.value.push(v);
              } while (this._match(TokenTypes.tokens.comma));
            }
            this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
          }
          attributes.push(attr);
        } while (this._match(TokenTypes.tokens.comma));
      }
      this._consume(TokenTypes.tokens.attr_right, "Expected ']]' after attribute declarations");
    }
    if (attributes.length == 0)
      return null;
    return attributes;
  }
};
var VariableInfo = class {
  constructor(node, group, binding) {
    this.group = group;
    this.binding = binding;
    this.node = node;
  }
  get name() {
    return this.node.name;
  }
  get type() {
    return this.node.type;
  }
  get attributes() {
    return this.node.attributes;
  }
};
var FunctionInfo = class {
  constructor(node) {
    this.inputs = [];
    this.node = node;
  }
  get name() {
    return this.node.name;
  }
  get returnType() {
    return this.node.returnType;
  }
  get args() {
    return this.node.args;
  }
  get attributes() {
    return this.node.attributes;
  }
};
var InputInfo = class {
  constructor(name, type, input, locationType, location) {
    this.name = name;
    this.type = type;
    this.input = input;
    this.locationType = locationType;
    this.location = location;
    this.interpolation = this.interpolation;
  }
};
var MemberInfo = class {
};
var TypeInfo = class {
  constructor(align, size) {
    this.align = align;
    this.size = size;
  }
};
var BufferInfo = class extends TypeInfo {
  constructor(name, type) {
    super(0, 0);
    this.name = name;
    this.type = type;
  }
};
var BindGropEntry = class {
  constructor(type, resource) {
    this.type = type;
    this.resource = resource;
  }
};
var EntryFunctions = class {
  constructor() {
    this.vertex = [];
    this.fragment = [];
    this.compute = [];
  }
};
var WgslReflect = class {
  constructor(code) {
    this.structs = [];
    this.uniforms = [];
    this.storage = [];
    this.textures = [];
    this.samplers = [];
    this.functions = [];
    this.aliases = [];
    if (code)
      this.initialize(code);
  }
  initialize(code) {
    const parser = new WgslParser();
    this.ast = parser.parse(code);
    this.entry = new EntryFunctions();
    for (const node of this.ast) {
      if (node.astNodeType == "struct")
        this.structs.push(node);
      if (node.astNodeType == "alias")
        this.aliases.push(node);
      if (this.isUniformVar(node)) {
        const v = node;
        const g = this.getAttributeNum(node, "group", 0);
        const b2 = this.getAttributeNum(node, "binding", 0);
        this.uniforms.push(new VariableInfo(v, g, b2));
      }
      if (this.isStorageVar(node)) {
        const v = node;
        const g = this.getAttributeNum(node, "group", 0);
        const b2 = this.getAttributeNum(node, "binding", 0);
        this.storage.push(new VariableInfo(v, g, b2));
      }
      if (this.isTextureVar(node)) {
        const v = node;
        const g = this.getAttributeNum(node, "group", 0);
        const b2 = this.getAttributeNum(node, "binding", 0);
        this.textures.push(new VariableInfo(v, g, b2));
      }
      if (this.isSamplerVar(node)) {
        const v = node;
        const g = this.getAttributeNum(node, "group", 0);
        const b2 = this.getAttributeNum(node, "binding", 0);
        this.samplers.push(new VariableInfo(v, g, b2));
      }
      if (node instanceof Function) {
        const fn = new FunctionInfo(node);
        fn.inputs = this._getInputs(node.args);
        this.functions.push(fn);
        const vertexStage = this.getAttribute(node, "vertex");
        const fragmentStage = this.getAttribute(node, "fragment");
        const computeStage = this.getAttribute(node, "compute");
        const stage = vertexStage || fragmentStage || computeStage;
        if (stage) {
          this.entry[stage.name].push(fn);
        }
      }
    }
  }
  isTextureVar(node) {
    return node instanceof Var && node.type !== null && WgslReflect.textureTypes.indexOf(node.type.name) != -1;
  }
  isSamplerVar(node) {
    return node instanceof Var && node.type !== null && WgslReflect.samplerTypes.indexOf(node.type.name) != -1;
  }
  isUniformVar(node) {
    return node instanceof Var && node.storage == "uniform";
  }
  isStorageVar(node) {
    return node instanceof Var && node.storage == "storage";
  }
  getAttributeNum(node, name, defaultValue) {
    const a = this.getAttribute(node, name);
    if (a == null) {
      return defaultValue;
    }
    let v = a !== null && a.value !== null ? a.value : defaultValue;
    if (v instanceof Array) {
      v = v[0];
    }
    if (typeof v === "number") {
      return v;
    }
    if (typeof v === "string") {
      return parseInt(v);
    }
    return defaultValue;
  }
  getAttribute(node, name) {
    const obj = node;
    if (!obj || !obj["attributes"])
      return null;
    const attrs = obj["attributes"];
    for (let a of attrs) {
      if (a.name == name)
        return a;
    }
    return null;
  }
  _getInputs(args, inputs = void 0) {
    if (inputs === void 0)
      inputs = [];
    for (const arg of args) {
      const input = this._getInputInfo(arg);
      if (input !== null)
        inputs.push(input);
      const struct = this.getStruct(arg.type);
      if (struct)
        this._getInputs(struct.members, inputs);
    }
    return inputs;
  }
  _getInputInfo(node) {
    const location = this.getAttribute(node, "location") || this.getAttribute(node, "builtin");
    if (location !== null) {
      const interpolation = this.getAttribute(node, "interpolation");
      const info = new InputInfo(node.name, node.type, node, location.name, this._parseInt(location.value));
      if (interpolation !== null) {
        info.interpolation = this._parseString(interpolation.value);
      }
      return info;
    }
    return null;
  }
  _parseString(s) {
    if (s instanceof Array) {
      s = s[0];
    }
    return s;
  }
  _parseInt(s) {
    if (s instanceof Array) {
      s = s[0];
    }
    const n = parseInt(s);
    return isNaN(n) ? s : n;
  }
  getStruct(name) {
    if (name === null)
      return null;
    if (name instanceof Struct)
      return name;
    name = this.getAlias(name) || name;
    if (name instanceof Type) {
      name = name.name;
    }
    for (const u of this.structs) {
      if (u.name == name)
        return u;
    }
    return null;
  }
  getAlias(type) {
    if (type === null)
      return null;
    if (type instanceof Node) {
      if (!(type instanceof Type)) {
        return null;
      }
      type = type.name;
    }
    for (const u of this.aliases) {
      if (u.name == type)
        return this.getAlias(u.type) || u.type;
    }
    return null;
  }
  getBindGroups() {
    const groups = [];
    function _makeRoom(group, binding) {
      if (group >= groups.length)
        groups.length = group + 1;
      if (groups[group] === void 0)
        groups[group] = [];
      if (binding >= groups[group].length)
        groups[group].length = binding + 1;
    }
    for (const u of this.uniforms) {
      _makeRoom(u.group, u.binding);
      const group = groups[u.group];
      group[u.binding] = new BindGropEntry("buffer", this.getUniformBufferInfo(u));
    }
    for (const u of this.storage) {
      _makeRoom(u.group, u.binding);
      const group = groups[u.group];
      group[u.binding] = new BindGropEntry("storage", this.getStorageBufferInfo(u));
    }
    for (const t of this.textures) {
      _makeRoom(t.group, t.binding);
      const group = groups[t.group];
      group[t.binding] = new BindGropEntry("texture", t);
    }
    for (const t of this.samplers) {
      _makeRoom(t.group, t.binding);
      const group = groups[t.group];
      group[t.binding] = new BindGropEntry("sampler", t);
    }
    return groups;
  }
  getStorageBufferInfo(node) {
    if (node instanceof VariableInfo) {
      node = node.node;
    }
    if (!this.isStorageVar(node))
      return null;
    const group = this.getAttributeNum(node, "group", 0);
    const binding = this.getAttributeNum(node, "binding", 0);
    const info = this._getUniformInfo(node);
    info.group = group;
    info.binding = binding;
    return info;
  }
  getStructInfo(node) {
    var _a2, _b, _c, _d, _e;
    if (node === null)
      return null;
    const struct = node instanceof Struct ? node : this.getStruct(node.type);
    if (!struct)
      return null;
    let offset = 0;
    let lastSize = 0;
    let lastOffset = 0;
    let structAlign = 0;
    let buffer = new BufferInfo(node.name, node instanceof Var ? node.type : null);
    buffer.members = [];
    for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {
      const member = struct.members[mi];
      const name = member.name;
      const info = this.getTypeInfo(member);
      if (!info)
        continue;
      const type = this.getAlias(member.type) || member.type;
      const align = info.align;
      const size = info.size;
      offset = this._roundUp(align, offset + lastSize);
      lastSize = size;
      lastOffset = offset;
      structAlign = Math.max(structAlign, align);
      const isArray = member.type.astNodeType === "array";
      const s = this.getStruct(type) || (isArray ? this.getStruct((_a2 = type["format"]) === null || _a2 === void 0 ? void 0 : _a2.name) : null);
      const isStruct = !!s;
      const si = isStruct ? this.getStructInfo(s) : void 0;
      const arrayStride = ((_b = si === null || si === void 0 ? void 0 : si.size) !== null && _b !== void 0 ? _b : isArray) ? (_c = this.getTypeInfo(type["format"])) === null || _c === void 0 ? void 0 : _c.size : (_d = this.getTypeInfo(member.type)) === null || _d === void 0 ? void 0 : _d.size;
      const arrayCount = (_e = member.type["count"]) !== null && _e !== void 0 ? _e : 0;
      const members = isStruct ? si === null || si === void 0 ? void 0 : si.members : void 0;
      const u = new MemberInfo();
      u.node = member;
      u.name = name;
      u.offset = offset;
      u.size = size;
      u.type = type;
      u.isArray = isArray;
      u.arrayCount = arrayCount;
      u.arrayStride = arrayStride;
      u.isStruct = isStruct;
      u.members = members;
      buffer.members.push(u);
    }
    buffer.size = this._roundUp(structAlign, lastOffset + lastSize);
    buffer.align = structAlign;
    buffer.isArray = false;
    buffer.isStruct = true;
    buffer.arrayCount = 0;
    return buffer;
  }
  _getUniformInfo(node) {
    var _a2, _b, _c, _d, _e;
    const structInfo = this.getStructInfo(node);
    if (structInfo !== null)
      return structInfo;
    var n = node;
    const typeInfo2 = this.getTypeInfo(n.type);
    if (typeInfo2 === null)
      return null;
    const type = this.getAlias(n.type) || n.type;
    const info = new BufferInfo(node.name, type);
    info.align = typeInfo2.align;
    info.size = typeInfo2.size;
    let s = this.getStruct((_a2 = type["format"]) === null || _a2 === void 0 ? void 0 : _a2.name);
    let si = s ? this.getStructInfo(s) : void 0;
    info.isArray = type.astNodeType === "array";
    info.isStruct = !!s;
    info.members = info.isStruct ? si === null || si === void 0 ? void 0 : si.members : void 0;
    info.name = n.name;
    info.type = type;
    info.arrayStride = ((_b = si === null || si === void 0 ? void 0 : si.size) !== null && _b !== void 0 ? _b : info.isArray) ? (_c = this.getTypeInfo(type["format"])) === null || _c === void 0 ? void 0 : _c.size : (_d = this.getTypeInfo(type)) === null || _d === void 0 ? void 0 : _d.size;
    info.arrayCount = parseInt((_e = type["count"]) !== null && _e !== void 0 ? _e : 0);
    return info;
  }
  getUniformBufferInfo(uniform) {
    if (!this.isUniformVar(uniform.node))
      return null;
    const info = this._getUniformInfo(uniform.node);
    info.group = uniform.group;
    info.binding = uniform.binding;
    return info;
  }
  getTypeInfo(type) {
    var _a2;
    if (type === null || type === void 0)
      return null;
    const explicitSize = this.getAttributeNum(type, "size", 0);
    const explicitAlign = this.getAttributeNum(type, "align", 0);
    if (type instanceof Member)
      type = type.type;
    if (type instanceof Type) {
      const alias = this.getAlias(type.name);
      if (alias !== null) {
        type = alias;
      }
      const struct = this.getStruct(type.name);
      if (struct !== null)
        type = struct;
    }
    {
      const info = WgslReflect.typeInfo[type.name];
      if (info !== void 0) {
        const divisor = type["format"] === "f16" ? 2 : 1;
        return new TypeInfo(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
      }
    }
    {
      const info = WgslReflect.typeInfo[type.name.substring(0, type.name.length - 1)];
      if (info) {
        const divisor = type.name[type.name.length - 1] === "h" ? 2 : 1;
        return new TypeInfo(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
      }
    }
    if (type.name == "array") {
      let align = 8;
      let size = 8;
      const E = this.getTypeInfo(type["format"]);
      if (E !== null) {
        size = E.size;
        align = E.align;
      }
      const N = parseInt((_a2 = type["count"]) !== null && _a2 !== void 0 ? _a2 : 1);
      const stride = this.getAttributeNum(type, "stride", this._roundUp(align, size));
      size = N * stride;
      if (explicitSize)
        size = explicitSize;
      return new TypeInfo(Math.max(explicitAlign, align), Math.max(explicitSize, size));
    }
    if (type instanceof Struct) {
      let align = 0;
      let size = 0;
      let offset = 0;
      let lastSize = 0;
      let lastOffset = 0;
      for (const m of type.members) {
        const mi = this.getTypeInfo(m);
        align = Math.max(mi.align, align);
        offset = this._roundUp(mi.align, offset + lastSize);
        lastSize = mi.size;
        lastOffset = offset;
      }
      size = this._roundUp(align, lastOffset + lastSize);
      return new TypeInfo(Math.max(explicitAlign, align), Math.max(explicitSize, size));
    }
    return null;
  }
  _roundUp(k, n) {
    return Math.ceil(n / k) * k;
  }
};
WgslReflect.typeInfo = {
  f16: { align: 2, size: 2 },
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  atomic: { align: 4, size: 4 },
  vec2: { align: 8, size: 8 },
  vec3: { align: 16, size: 12 },
  vec4: { align: 16, size: 16 },
  mat2x2: { align: 8, size: 16 },
  mat3x2: { align: 8, size: 24 },
  mat4x2: { align: 8, size: 32 },
  mat2x3: { align: 16, size: 32 },
  mat3x3: { align: 16, size: 48 },
  mat4x3: { align: 16, size: 64 },
  mat2x4: { align: 16, size: 32 },
  mat3x4: { align: 16, size: 48 },
  mat4x4: { align: 16, size: 64 }
};
WgslReflect.textureTypes = TokenTypes.any_texture_type.map((t) => {
  return t.name;
});
WgslReflect.samplerTypes = TokenTypes.sampler_type.map((t) => {
  return t.name;
});
function makeShaderDataDefinitions(code) {
  const reflect = new WgslReflect(code);
  const structs = Object.fromEntries(reflect.structs.map((struct) => {
    const info = reflect.getStructInfo(struct);
    return [struct.name, addMembers(reflect, info.members, info.size)];
  }));
  const uniforms = Object.fromEntries(reflect.uniforms.map((uniform) => {
    const info = reflect.getUniformBufferInfo(uniform);
    const member = addMember(reflect, info, 0)[1];
    member.binding = info.binding;
    member.group = info.group;
    return [uniform.name, member];
  }));
  const storages = Object.fromEntries(reflect.storage.map((uniform) => {
    const info = reflect.getStorageBufferInfo(uniform);
    const member = addMember(reflect, info, 0)[1];
    member.binding = info.binding;
    member.group = info.group;
    return [uniform.name, member];
  }));
  return {
    structs,
    storages,
    uniforms
  };
}
function addMember(reflect, m, offset) {
  var _a2, _b;
  if (m.isArray) {
    if (m.isStruct) {
      return [
        m.name,
        new Array(m.arrayCount).fill(0).map((_, ndx) => {
          return addMembers(reflect, m.members, m.size / m.arrayCount, offset + (m.offset || 0) + m.size / m.arrayCount * ndx);
        })
      ];
    } else {
      return [
        m.name,
        {
          offset: offset + (m.offset || 0),
          size: m.size,
          type: m.type.format.format ? `${m.type.format.name}<${m.type.format.format.name}>` : m.type.format.name,
          numElements: m.arrayCount
        }
      ];
    }
  } else if (m.isStruct) {
    return [
      m.name,
      addMembers(reflect, m.members, m.size, offset + (m.offset || 0))
    ];
  } else {
    return [
      m.name,
      {
        offset: offset + (m.offset || 0),
        size: m.size,
        type: ((_a2 = m.type) == null ? void 0 : _a2.format) ? `${m.type.name}<${m.type.format.name}>` : ((_b = m.type) == null ? void 0 : _b.name) || m.name
      }
    ];
  }
}
function addMembers(reflect, members, size, offset = 0) {
  const fields = Object.fromEntries(members.map((m) => {
    return addMember(reflect, m, offset);
  }));
  return {
    fields,
    size
  };
}
function getViewDimensionForTexture(texture) {
  switch (texture.dimension) {
    case "1d":
      return "1d";
    case "3d":
      return "3d";
    default:
    case "2d":
      return texture.depthOrArrayLayers > 1 ? "2d-array" : "2d";
  }
}
function normalizeGPUExtent3Dict(size) {
  return [size.width, size.height || 1, size.depthOrArrayLayers || 1];
}
function normalizeGPUExtent3D(size) {
  return Array.isArray(size) || isTypedArray(size) ? [...size, 1, 1].slice(0, 3) : normalizeGPUExtent3Dict(size);
}
function numMipLevels(size) {
  const sizes = normalizeGPUExtent3D(size);
  const maxSize = Math.max(...sizes);
  return 1 + Math.log2(maxSize) | 0;
}
var byDevice = /* @__PURE__ */ new WeakMap();
function generateMipmap(device, texture) {
  let perDeviceInfo = byDevice.get(device);
  if (!perDeviceInfo) {
    perDeviceInfo = {
      pipelineByFormatAndView: {},
      moduleByView: {}
    };
    byDevice.set(device, perDeviceInfo);
  }
  let { sampler } = perDeviceInfo;
  const { pipelineByFormatAndView, moduleByView } = perDeviceInfo;
  const view = getViewDimensionForTexture(texture);
  let module = moduleByView[view];
  if (!module) {
    const type = view === "2d" ? "texture_2d<f32>" : "texture_2d_array<f32>";
    const extraSampleParamsWGSL = view === "2d" ? "" : ", 0u";
    module = device.createShaderModule({
      label: `mip level generation for ${view}`,
      code: `
        struct VSOutput {
          @builtin(position) position: vec4f,
          @location(0) texcoord: vec2f,
        };

        @vertex fn vs(
          @builtin(vertex_index) vertexIndex : u32
        ) -> VSOutput {
          var pos = array<vec2f, 3>(
            vec2f(-1.0, -1.0),
            vec2f(-1.0,  3.0),
            vec2f( 3.0, -1.0),
          );

          var vsOutput: VSOutput;
          let xy = pos[vertexIndex];
          vsOutput.position = vec4f(xy, 0.0, 1.0);
          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
          return vsOutput;
        }

        @group(0) @binding(0) var ourSampler: sampler;
        @group(0) @binding(1) var ourTexture: ${type};

        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {
          return textureSample(ourTexture, ourSampler, fsInput.texcoord${extraSampleParamsWGSL});
        }
      `
    });
    moduleByView[view] = module;
  }
  if (!sampler) {
    sampler = device.createSampler({
      minFilter: "linear"
    });
    perDeviceInfo.sampler = sampler;
  }
  const id = `${texture.format}.${view}`;
  if (!pipelineByFormatAndView[id]) {
    pipelineByFormatAndView[id] = device.createRenderPipeline({
      label: `mip level generator pipeline for ${view}`,
      layout: "auto",
      vertex: {
        module,
        entryPoint: "vs"
      },
      fragment: {
        module,
        entryPoint: "fs",
        targets: [{ format: texture.format }]
      }
    });
  }
  const pipeline = pipelineByFormatAndView[id];
  const encoder = device.createCommandEncoder({
    label: "mip gen encoder"
  });
  const dimension = getViewDimensionForTexture(texture);
  for (let baseMipLevel = 1; baseMipLevel < texture.mipLevelCount; ++baseMipLevel) {
    for (let baseArrayLayer = 0; baseArrayLayer < texture.depthOrArrayLayers; ++baseArrayLayer) {
      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: sampler },
          {
            binding: 1,
            resource: texture.createView({
              dimension,
              baseMipLevel: baseMipLevel - 1,
              mipLevelCount: 1,
              baseArrayLayer,
              arrayLayerCount: 1
            })
          }
        ]
      });
      const renderPassDescriptor = {
        label: "mip gen renderPass",
        colorAttachments: [
          {
            view: texture.createView({
              dimension,
              baseMipLevel,
              mipLevelCount: 1,
              baseArrayLayer,
              arrayLayerCount: 1
            }),
            loadOp: "clear",
            storeOp: "store"
          }
        ]
      };
      const pass = encoder.beginRenderPass(renderPassDescriptor);
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
    }
  }
  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);
}
var kTypedArrayToAttribFormat = /* @__PURE__ */ new Map([
  [Int8Array, { formats: ["sint8", "snorm8"], defaultForType: 1 }],
  [Uint8Array, { formats: ["uint8", "unorm8"], defaultForType: 1 }],
  [Int16Array, { formats: ["sint16", "snorm16"], defaultForType: 1 }],
  [Uint16Array, { formats: ["uint16", "unorm16"], defaultForType: 1 }],
  [Int32Array, { formats: ["sint32", "snorm32"], defaultForType: 0 }],
  [Uint32Array, { formats: ["uint32", "unorm32"], defaultForType: 0 }],
  [Float32Array, { formats: ["float32", "float32"], defaultForType: 0 }]
]);
var kVertexFormatPrefixToType = new Map([...kTypedArrayToAttribFormat.entries()].map(([Type2, { formats: [s1, s2] }]) => [[s1, Type2], [s2, Type2]]).flat());
function isIndices(name) {
  return name === "indices";
}
function makeTypedArrayFromArrayUnion(array, name) {
  if (isTypedArray(array)) {
    return array;
  }
  let asFullSpec = array;
  if (isTypedArray(asFullSpec.data)) {
    return asFullSpec.data;
  }
  if (Array.isArray(array) || typeof array === "number") {
    asFullSpec = {
      data: array
    };
  }
  let Type2 = asFullSpec.type;
  if (!Type2) {
    if (isIndices(name)) {
      Type2 = Uint32Array;
    } else {
      Type2 = Float32Array;
    }
  }
  return new Type2(asFullSpec.data);
}
function getArray(array) {
  const arr = array.length ? array : array.data;
  return arr;
}
var kNameToNumComponents = [
  { re: /coord|texture|uv/i, numComponents: 2 },
  { re: /color|colour/i, numComponents: 4 }
];
function guessNumComponentsFromNameImpl(name) {
  for (const { re, numComponents } of kNameToNumComponents) {
    if (re.test(name)) {
      return numComponents;
    }
  }
  return 3;
}
function guessNumComponentsFromName(name, length) {
  const numComponents = guessNumComponentsFromNameImpl(name);
  if (length % numComponents > 0) {
    throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);
  }
  return numComponents;
}
function getNumComponents(array, arrayName) {
  return array.numComponents || guessNumComponentsFromName(arrayName, getArray(array).length);
}
var kVertexFormatRE = /(\w+)(?:x(\d))$/;
function numComponentsAndTypeFromVertexFormat(format) {
  const m = kVertexFormatRE.exec(format);
  const [prefix, numComponents] = m ? [m[1], parseInt(m[2])] : [format, 1];
  return {
    Type: kVertexFormatPrefixToType.get(prefix),
    numComponents
  };
}
function createTypedArrayOfSameType(typedArray, arrayBuffer) {
  const Ctor = Object.getPrototypeOf(typedArray).constructor;
  return new Ctor(arrayBuffer);
}
function createBufferLayoutsFromArrays(arrays, options = {}) {
  const interleave = options.interleave === void 0 ? true : options.interleave;
  const stepMode = options.stepMode || "vertex";
  const shaderLocations = options.shaderLocation ? Array.isArray(options.shaderLocation) ? options.shaderLocation : [options.shaderLocation] : [0];
  let currentOffset = 0;
  const bufferLayouts = [];
  const attributes = [];
  const typedArrays = [];
  Object.keys(arrays).filter((arrayName) => !isIndices(arrayName)).forEach((arrayName) => {
    const array = arrays[arrayName];
    const data = makeTypedArrayFromArrayUnion(array, arrayName);
    const totalNumComponents = getNumComponents(array, arrayName);
    const by4 = totalNumComponents / 4;
    const by3 = totalNumComponents / 3;
    const step = by4 % 1 === 0 ? 4 : by3 % 1 === 0 ? 3 : 4;
    for (let component = 0; component < totalNumComponents; component += step) {
      const numComponents = Math.min(step, totalNumComponents - component);
      const offset = currentOffset;
      currentOffset += numComponents * data.BYTES_PER_ELEMENT;
      const { defaultForType, formats } = kTypedArrayToAttribFormat.get(Object.getPrototypeOf(data).constructor);
      const normalize = array.normalize;
      const formatNdx = typeof normalize === "undefined" ? defaultForType : normalize ? 1 : 0;
      const format = `${formats[formatNdx]}${numComponents > 1 ? `x${numComponents}` : ""}`;
      const shaderLocation = shaderLocations.shift();
      if (shaderLocations.length === 0) {
        shaderLocations.push(shaderLocation + 1);
      }
      attributes.push({
        offset,
        format,
        shaderLocation
      });
      typedArrays.push({
        data,
        offset: component,
        stride: totalNumComponents
      });
    }
    if (!interleave) {
      bufferLayouts.push({
        stepMode,
        arrayStride: currentOffset,
        attributes: attributes.slice()
      });
      currentOffset = 0;
      attributes.length = 0;
    }
  });
  if (attributes.length) {
    bufferLayouts.push({
      stepMode,
      arrayStride: currentOffset,
      attributes
    });
  }
  return {
    bufferLayouts,
    typedArrays
  };
}
function getTypedArrayWithOffsetAndStride(ta, numComponents) {
  return isTypedArray(ta) ? { data: ta, offset: 0, stride: numComponents } : ta;
}
function interleaveVertexData(attributes, typedArrays, arrayStride, arrayBuffer) {
  const views = /* @__PURE__ */ new Map();
  const getView2 = (typedArray) => {
    const Ctor = Object.getPrototypeOf(typedArray).constructor;
    const view = views.get(Ctor);
    if (view) {
      return view;
    }
    const newView = new Ctor(arrayBuffer);
    views.set(Ctor, newView);
    return newView;
  };
  attributes.forEach((attribute, ndx) => {
    const { offset, format } = attribute;
    const { numComponents } = numComponentsAndTypeFromVertexFormat(format);
    const { data, offset: srcOffset, stride } = getTypedArrayWithOffsetAndStride(typedArrays[ndx], numComponents);
    const view = getView2(data);
    for (let i = 0; i < data.length; i += stride) {
      const ndx2 = i / stride;
      const dstOffset = (offset + ndx2 * arrayStride) / view.BYTES_PER_ELEMENT;
      const srcOff = i + srcOffset;
      const s = data.subarray(srcOff, srcOff + numComponents);
      view.set(s, dstOffset);
    }
  });
}
function createBuffersAndAttributesFromArrays(device, arrays, options = {}) {
  const usage = options.usage || 0;
  const { bufferLayouts, typedArrays } = createBufferLayoutsFromArrays(arrays, options);
  const buffers = [];
  let numElements = -1;
  let bufferNdx = 0;
  for (const { attributes, arrayStride } of bufferLayouts) {
    const attribs = attributes;
    const attrib0 = attribs[0];
    const { numComponents } = numComponentsAndTypeFromVertexFormat(attrib0.format);
    const { data: data0, stride } = getTypedArrayWithOffsetAndStride(typedArrays[bufferNdx], numComponents);
    if (numElements < 0) {
      numElements = data0.length / stride;
    }
    const size = arrayStride * numElements;
    const buffer = device.createBuffer({
      usage: usage | GPUBufferUsage.VERTEX,
      size,
      mappedAtCreation: true
    });
    const arrayBuffer = buffer.getMappedRange();
    if (attribs.length === 1 && arrayStride === data0.BYTES_PER_ELEMENT * numComponents) {
      const view = createTypedArrayOfSameType(data0, arrayBuffer);
      view.set(data0);
    } else {
      interleaveVertexData(attribs, typedArrays.slice(bufferNdx), arrayStride, arrayBuffer);
    }
    buffer.unmap();
    buffers.push(buffer);
    bufferNdx += attribs.length;
  }
  const buffersAndAttributes = {
    numElements,
    bufferLayouts,
    buffers
  };
  const indicesEntry = Object.entries(arrays).find(([arrayName]) => isIndices(arrayName));
  if (indicesEntry) {
    const indices = makeTypedArrayFromArrayUnion(indicesEntry[1], "indices");
    const indexBuffer = device.createBuffer({
      size: indices.byteLength,
      usage: GPUBufferUsage.INDEX | usage,
      mappedAtCreation: true
    });
    const dst = createTypedArrayOfSameType(indices, indexBuffer.getMappedRange());
    dst.set(indices);
    indexBuffer.unmap();
    buffersAndAttributes.indexBuffer = indexBuffer;
    buffersAndAttributes.indexFormat = indices instanceof Uint16Array ? "uint16" : "uint32";
    buffersAndAttributes.numElements = indices.length;
  }
  return buffersAndAttributes;
}
function isTextureData(source) {
  const src = source;
  return isTypedArray(src.data) || Array.isArray(src.data);
}
function isTextureRawDataSource(source) {
  return isTypedArray(source) || Array.isArray(source) || isTextureData(source);
}
function toTypedArray(v, format) {
  if (isTypedArray(v)) {
    return v;
  }
  const { Type: Type2 } = getTextureFormatInfo(format);
  return new Type2(v);
}
function guessDimensions(width, height, numElements, dimension = "2d") {
  if (numElements % 1 !== 0) {
    throw new Error("can't guess dimensions");
  }
  if (!width && !height) {
    const size = Math.sqrt(numElements / (dimension === "cube" ? 6 : 1));
    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;
    if (height % 1) {
      throw new Error("can't guess dimensions");
    }
  } else if (!width) {
    width = numElements / height;
    if (width % 1) {
      throw new Error("can't guess dimensions");
    }
  }
  const depth = numElements / width / height;
  if (depth % 1) {
    throw new Error("can't guess dimensions");
  }
  return [width, height, depth];
}
function textureViewDimensionToDimension(viewDimension) {
  switch (viewDimension) {
    case "1d":
      return "1d";
    case "3d":
      return "3d";
    default:
      return "2d";
  }
}
var kFormatToTypedArray = {
  "8snorm": Int8Array,
  "8unorm": Uint8Array,
  "8sint": Int8Array,
  "8uint": Uint8Array,
  "16snorm": Int16Array,
  "16unorm": Uint16Array,
  "16sint": Int16Array,
  "16uint": Uint16Array,
  "32snorm": Int32Array,
  "32unorm": Uint32Array,
  "32sint": Int32Array,
  "32uint": Uint32Array,
  "16float": Uint16Array,
  "32float": Float32Array
};
var kTextureFormatRE = /([a-z]+)(\d+)([a-z]+)/;
function getTextureFormatInfo(format) {
  const [, channels, bits, typeName] = kTextureFormatRE.exec(format);
  const numChannels = channels.length;
  const bytesPerChannel = parseInt(bits) / 8;
  const bytesPerElement = numChannels * bytesPerChannel;
  const Type2 = kFormatToTypedArray[`${bits}${typeName}`];
  return {
    channels,
    numChannels,
    bytesPerChannel,
    bytesPerElement,
    Type: Type2
  };
}
function getSizeForMipFromTexture(texture, mipLevel) {
  return [
    texture.width,
    texture.height,
    texture.depthOrArrayLayers
  ].map((v) => Math.max(1, Math.floor(v / 2 ** mipLevel)));
}
function uploadDataToTexture(device, texture, source, options) {
  const data = toTypedArray(source.data || source, texture.format);
  const mipLevel = 0;
  const size = getSizeForMipFromTexture(texture, mipLevel);
  const { bytesPerElement } = getTextureFormatInfo(texture.format);
  const origin = options.origin || [0, 0, 0];
  device.queue.writeTexture({ texture, origin }, data, { bytesPerRow: bytesPerElement * size[0], rowsPerImage: size[1] }, size);
}
function copySourcesToTexture(device, texture, sources, options = {}) {
  sources.forEach((source, layer) => {
    const origin = [0, 0, layer + (options.baseArrayLayer || 0)];
    if (isTextureRawDataSource(source)) {
      uploadDataToTexture(device, texture, source, { origin });
    } else {
      const s = source;
      const { flipY, premultipliedAlpha, colorSpace } = options;
      device.queue.copyExternalImageToTexture({ source: s, flipY }, { texture, premultipliedAlpha, colorSpace, origin }, getSizeFromSource(s, options));
    }
  });
  if (texture.mipLevelCount > 1) {
    generateMipmap(device, texture);
  }
}
function copySourceToTexture(device, texture, source, options = {}) {
  copySourcesToTexture(device, texture, [source], options);
}
function getSizeFromSource(source, options) {
  if (source instanceof HTMLVideoElement) {
    return [source.videoWidth, source.videoHeight, 1];
  } else {
    const maybeHasWidthAndHeight = source;
    const { width, height } = maybeHasWidthAndHeight;
    if (width > 0 && height > 0 && !isTextureRawDataSource(source)) {
      return [width, height, 1];
    }
    const format = options.format || "rgba8unorm";
    const { bytesPerElement, bytesPerChannel } = getTextureFormatInfo(format);
    const data = isTypedArray(source) || Array.isArray(source) ? source : source.data;
    const numBytes = isTypedArray(data) ? data.byteLength : data.length * bytesPerChannel;
    const numElements = numBytes / bytesPerElement;
    return guessDimensions(width, height, numElements);
  }
}
function createTextureFromSources(device, sources, options = {}) {
  var _a2;
  const size = getSizeFromSource(sources[0], options);
  size[2] = size[2] > 1 ? size[2] : sources.length;
  const texture = device.createTexture({
    dimension: textureViewDimensionToDimension(options.dimension),
    format: options.format || "rgba8unorm",
    mipLevelCount: options.mipLevelCount ? options.mipLevelCount : options.mips ? numMipLevels(size) : 1,
    size,
    usage: ((_a2 = options.usage) != null ? _a2 : 0) | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
  });
  copySourcesToTexture(device, texture, sources, options);
  return texture;
}
function createTextureFromSource(device, source, options = {}) {
  return createTextureFromSources(device, [source], options);
}
async function loadImageBitmap(url, options = {}) {
  const res = await fetch(url);
  const blob = await res.blob();
  const opt = {
    ...options,
    ...options.colorSpaceConversion !== void 0 && { colorSpaceConversion: "none" }
  };
  return await createImageBitmap(blob, opt);
}
async function createTextureFromImages(device, urls, options = {}) {
  const imgBitmaps = await Promise.all(urls.map((url) => loadImageBitmap(url)));
  return createTextureFromSources(device, imgBitmaps, options);
}
async function createTextureFromImage(device, url, options = {}) {
  return createTextureFromImages(device, [url], options);
}
var TypedArrayWrapper = class {
  constructor(arr, numComponents) {
    __publicField(this, "typedArray");
    __publicField(this, "cursor", 0);
    __publicField(this, "numComponents");
    this.typedArray = arr;
    this.numComponents = numComponents;
  }
  get numElements() {
    return this.typedArray.length / this.numComponents;
  }
  push(...data) {
    for (const value of data) {
      if (Array.isArray(value) || isTypedArray(value)) {
        const asArray = data;
        this.typedArray.set(asArray, this.cursor);
        this.cursor += asArray.length;
      } else {
        this.typedArray[this.cursor++] = value;
      }
    }
  }
  reset(index = 0) {
    this.cursor = index;
  }
};
function createAugmentedTypedArray(numComponents, numElements, Type2) {
  return new TypedArrayWrapper(new Type2(numComponents * numElements), numComponents);
}
function createXYQuadVertices(size = 2, xOffset = 0, yOffset = 0) {
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [
        xOffset + -1 * size,
        yOffset + -1 * size,
        xOffset + 1 * size,
        yOffset + -1 * size,
        xOffset + -1 * size,
        yOffset + 1 * size,
        xOffset + 1 * size,
        yOffset + 1 * size
      ]
    },
    normal: [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ],
    texcoord: [
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      1
    ],
    indices: [0, 1, 2, 2, 1, 3]
  };
}
function createPlaneVertices(width = 1, depth = 1, subdivisionsWidth = 1, subdivisionsDepth = 1) {
  const numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  for (let z = 0; z <= subdivisionsDepth; z++) {
    for (let x = 0; x <= subdivisionsWidth; x++) {
      const u = x / subdivisionsWidth;
      const v = z / subdivisionsDepth;
      positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }
  const numVertsAcross = subdivisionsWidth + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);
  for (let z = 0; z < subdivisionsDepth; z++) {
    for (let x = 0; x < subdivisionsWidth; x++) {
      indices.push((z + 0) * numVertsAcross + x, (z + 1) * numVertsAcross + x, (z + 0) * numVertsAcross + x + 1);
      indices.push((z + 1) * numVertsAcross + x, (z + 1) * numVertsAcross + x + 1, (z + 0) * numVertsAcross + x + 1);
    }
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
function createSphereVertices(radius = 1, subdivisionsAxis = 24, subdivisionsHeight = 12, startLatitudeInRadians = 0, endLatitudeInRadians = Math.PI, startLongitudeInRadians = 0, endLongitudeInRadians = Math.PI * 2) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error("subdivisionAxis and subdivisionHeight must be > 0");
  }
  const latRange = endLatitudeInRadians - startLatitudeInRadians;
  const longRange = endLongitudeInRadians - startLongitudeInRadians;
  const numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  for (let y = 0; y <= subdivisionsHeight; y++) {
    for (let x = 0; x <= subdivisionsAxis; x++) {
      const u = x / subdivisionsAxis;
      const v = y / subdivisionsHeight;
      const theta = longRange * u + startLongitudeInRadians;
      const phi = latRange * v + startLatitudeInRadians;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }
  const numVertsAround = subdivisionsAxis + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);
  for (let x = 0; x < subdivisionsAxis; x++) {
    for (let y = 0; y < subdivisionsHeight; y++) {
      indices.push((y + 0) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x);
      indices.push((y + 1) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x + 1);
    }
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
var CUBE_FACE_INDICES = [
  [3, 7, 5, 1],
  [6, 2, 0, 4],
  [6, 7, 3, 2],
  [0, 1, 5, 4],
  [7, 6, 4, 5],
  [2, 3, 1, 0]
];
function createCubeVertices(size = 1) {
  const k = size / 2;
  const cornerVertices = [
    [-k, -k, -k],
    [+k, -k, -k],
    [-k, +k, -k],
    [+k, +k, -k],
    [-k, -k, +k],
    [+k, -k, +k],
    [-k, +k, +k],
    [+k, +k, +k]
  ];
  const faceNormals = [
    [1, 0, 0],
    [-1, 0, 0],
    [0, 1, 0],
    [0, -1, 0],
    [0, 0, 1],
    [0, 0, -1]
  ];
  const uvCoords = [
    [1, 0],
    [0, 0],
    [0, 1],
    [1, 1]
  ];
  const numVertices = 6 * 4;
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  const indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);
  for (let f = 0; f < 6; ++f) {
    const faceIndices = CUBE_FACE_INDICES[f];
    for (let v = 0; v < 4; ++v) {
      const position = cornerVertices[faceIndices[v]];
      const normal = faceNormals[f];
      const uv = uvCoords[v];
      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);
    }
    const offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
function createTruncatedConeVertices(bottomRadius = 1, topRadius = 0, height = 1, radialSubdivisions = 24, verticalSubdivisions = 1, topCap = true, bottomCap = true) {
  if (radialSubdivisions < 3) {
    throw new Error("radialSubdivisions must be 3 or greater");
  }
  if (verticalSubdivisions < 1) {
    throw new Error("verticalSubdivisions must be 1 or greater");
  }
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  const indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);
  const vertsAroundEdge = radialSubdivisions + 1;
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const cosSlant = Math.cos(slant);
  const sinSlant = Math.sin(slant);
  const start = topCap ? -2 : 0;
  const end = verticalSubdivisions + (bottomCap ? 2 : 0);
  for (let yy = start; yy <= end; ++yy) {
    let v = yy / verticalSubdivisions;
    let y = height * v;
    let ringRadius;
    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }
    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let ii = 0; ii < vertsAroundEdge; ++ii) {
      const sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      const cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);
      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }
      texcoords.push(ii / radialSubdivisions, 1 - v);
    }
  }
  for (let yy = 0; yy < verticalSubdivisions + extra; ++yy) {
    if (yy === 1 && topCap || yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }
    for (let ii = 0; ii < radialSubdivisions; ++ii) {
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 0) + 1 + ii, vertsAroundEdge * (yy + 1) + 1 + ii);
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 1) + 1 + ii, vertsAroundEdge * (yy + 1) + 0 + ii);
    }
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
function expandRLEData(rleData, padding = []) {
  padding = padding || [];
  const data = [];
  for (let ii = 0; ii < rleData.length; ii += 4) {
    const runLength = rleData[ii];
    const element = rleData.slice(ii + 1, ii + 4);
    element.push(...padding);
    for (let jj = 0; jj < runLength; ++jj) {
      data.push(...element);
    }
  }
  return data;
}
function create3DFVertices() {
  const positions = [
    0,
    0,
    0,
    0,
    150,
    0,
    30,
    0,
    0,
    0,
    150,
    0,
    30,
    150,
    0,
    30,
    0,
    0,
    30,
    0,
    0,
    30,
    30,
    0,
    100,
    0,
    0,
    30,
    30,
    0,
    100,
    30,
    0,
    100,
    0,
    0,
    30,
    60,
    0,
    30,
    90,
    0,
    67,
    60,
    0,
    30,
    90,
    0,
    67,
    90,
    0,
    67,
    60,
    0,
    0,
    0,
    30,
    30,
    0,
    30,
    0,
    150,
    30,
    0,
    150,
    30,
    30,
    0,
    30,
    30,
    150,
    30,
    30,
    0,
    30,
    100,
    0,
    30,
    30,
    30,
    30,
    30,
    30,
    30,
    100,
    0,
    30,
    100,
    30,
    30,
    30,
    60,
    30,
    67,
    60,
    30,
    30,
    90,
    30,
    30,
    90,
    30,
    67,
    60,
    30,
    67,
    90,
    30,
    0,
    0,
    0,
    100,
    0,
    0,
    100,
    0,
    30,
    0,
    0,
    0,
    100,
    0,
    30,
    0,
    0,
    30,
    100,
    0,
    0,
    100,
    30,
    0,
    100,
    30,
    30,
    100,
    0,
    0,
    100,
    30,
    30,
    100,
    0,
    30,
    30,
    30,
    0,
    30,
    30,
    30,
    100,
    30,
    30,
    30,
    30,
    0,
    100,
    30,
    30,
    100,
    30,
    0,
    30,
    30,
    0,
    30,
    60,
    30,
    30,
    30,
    30,
    30,
    30,
    0,
    30,
    60,
    0,
    30,
    60,
    30,
    30,
    60,
    0,
    67,
    60,
    30,
    30,
    60,
    30,
    30,
    60,
    0,
    67,
    60,
    0,
    67,
    60,
    30,
    67,
    60,
    0,
    67,
    90,
    30,
    67,
    60,
    30,
    67,
    60,
    0,
    67,
    90,
    0,
    67,
    90,
    30,
    30,
    90,
    0,
    30,
    90,
    30,
    67,
    90,
    30,
    30,
    90,
    0,
    67,
    90,
    30,
    67,
    90,
    0,
    30,
    90,
    0,
    30,
    150,
    30,
    30,
    90,
    30,
    30,
    90,
    0,
    30,
    150,
    0,
    30,
    150,
    30,
    0,
    150,
    0,
    0,
    150,
    30,
    30,
    150,
    30,
    0,
    150,
    0,
    30,
    150,
    30,
    30,
    150,
    0,
    0,
    0,
    0,
    0,
    0,
    30,
    0,
    150,
    30,
    0,
    0,
    0,
    0,
    150,
    30,
    0,
    150,
    0
  ];
  const texcoords = [
    0.22,
    0.19,
    0.22,
    0.79,
    0.34,
    0.19,
    0.22,
    0.79,
    0.34,
    0.79,
    0.34,
    0.19,
    0.34,
    0.19,
    0.34,
    0.31,
    0.62,
    0.19,
    0.34,
    0.31,
    0.62,
    0.31,
    0.62,
    0.19,
    0.34,
    0.43,
    0.34,
    0.55,
    0.49,
    0.43,
    0.34,
    0.55,
    0.49,
    0.55,
    0.49,
    0.43,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0
  ];
  const normals = expandRLEData([
    18,
    0,
    0,
    1,
    18,
    0,
    0,
    -1,
    6,
    0,
    1,
    0,
    6,
    1,
    0,
    0,
    6,
    0,
    -1,
    0,
    6,
    1,
    0,
    0,
    6,
    0,
    1,
    0,
    6,
    1,
    0,
    0,
    6,
    0,
    -1,
    0,
    6,
    1,
    0,
    0,
    6,
    0,
    -1,
    0,
    6,
    -1,
    0,
    0
  ]);
  const colors = expandRLEData([
    18,
    200,
    70,
    120,
    18,
    80,
    70,
    200,
    6,
    70,
    200,
    210,
    6,
    200,
    200,
    70,
    6,
    210,
    100,
    70,
    6,
    210,
    160,
    70,
    6,
    70,
    180,
    210,
    6,
    100,
    70,
    210,
    6,
    76,
    210,
    100,
    6,
    140,
    210,
    80,
    6,
    90,
    130,
    110,
    6,
    160,
    160,
    220
  ], [255]);
  const numVerts = positions.length / 3;
  const arrays = {
    position: createAugmentedTypedArray(3, numVerts, Float32Array),
    texcoord: createAugmentedTypedArray(2, numVerts, Float32Array),
    normal: createAugmentedTypedArray(3, numVerts, Float32Array),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)
  };
  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);
  for (let ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }
  return Object.fromEntries(Object.entries(arrays).map(([k, v]) => [k, v.typedArray]));
}
function createCrescentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error("subdivisionDown must be > 0");
  }
  const subdivisionsThick = 2;
  const offsetRange = endOffset - startOffset;
  const numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  function lerp(a, b2, s) {
    return a + (b2 - a) * s;
  }
  function vAdd(a, b2) {
    return a.map((v, i) => v + b2[i]);
  }
  function vMultiply(a, b2) {
    return a.map((v, i) => v * b2[i]);
  }
  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (let z = 0; z <= subdivisionsDown; z++) {
      const uBack = x / (subdivisionsThick - 1);
      const v = z / subdivisionsDown;
      const xBack = (uBack - 0.5) * 2;
      const angle = (startOffset + v * offsetRange) * Math.PI;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const radius = lerp(verticalRadius, arcRadius, s);
      const px = xBack * thickness;
      const py = c * verticalRadius;
      const pz = s * radius;
      positions.push(px, py, pz);
      const n = vAdd(vMultiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  }
  for (let x = 0; x < subdivisionsThick; x++) {
    const uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  }
  const indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);
  function createSurface(leftArcOffset, rightArcOffset) {
    for (let z = 0; z < subdivisionsDown; ++z) {
      indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0);
      indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);
    }
  }
  const numVerticesDown = subdivisionsDown + 1;
  createSurface(numVerticesDown * 0, numVerticesDown * 4);
  createSurface(numVerticesDown * 5, numVerticesDown * 7);
  createSurface(numVerticesDown * 6, numVerticesDown * 2);
  createSurface(numVerticesDown * 3, numVerticesDown * 1);
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
function createCylinderVertices(radius = 1, height = 1, radialSubdivisions = 24, verticalSubdivisions = 1, topCap = true, bottomCap = true) {
  return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);
}
function createTorusVertices(radius = 1, thickness = 0.24, radialSubdivisions = 24, bodySubdivisions = 12, startAngle = 0, endAngle = Math.PI * 2) {
  if (radialSubdivisions < 3) {
    throw new Error("radialSubdivisions must be 3 or greater");
  }
  if (bodySubdivisions < 3) {
    throw new Error("verticalSubdivisions must be 3 or greater");
  }
  const range = endAngle - startAngle;
  const radialParts = radialSubdivisions + 1;
  const bodyParts = bodySubdivisions + 1;
  const numVertices = radialParts * bodyParts;
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  const indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);
  for (let slice = 0; slice < bodyParts; ++slice) {
    const v = slice / bodySubdivisions;
    const sliceAngle = v * Math.PI * 2;
    const sliceSin = Math.sin(sliceAngle);
    const ringRadius = radius + sliceSin * thickness;
    const ny = Math.cos(sliceAngle);
    const y = ny * thickness;
    for (let ring = 0; ring < radialParts; ++ring) {
      const u = ring / radialSubdivisions;
      const ringAngle = startAngle + u * range;
      const xSin = Math.sin(ringAngle);
      const zCos = Math.cos(ringAngle);
      const x = xSin * ringRadius;
      const z = zCos * ringRadius;
      const nx = xSin * sliceSin;
      const nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }
  for (let slice = 0; slice < bodySubdivisions; ++slice) {
    for (let ring = 0; ring < radialSubdivisions; ++ring) {
      const nextRingIndex = 1 + ring;
      const nextSliceIndex = 1 + slice;
      indices.push(radialParts * slice + ring, radialParts * nextSliceIndex + ring, radialParts * slice + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * slice + nextRingIndex);
    }
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
function createDiscVertices(radius = 1, divisions = 24, stacks = 1, innerRadius = 0, stackPower = 1) {
  if (divisions < 3) {
    throw new Error("divisions must be at least 3");
  }
  const numVertices = (divisions + 1) * (stacks + 1);
  const positions = createAugmentedTypedArray(3, numVertices, Float32Array);
  const normals = createAugmentedTypedArray(3, numVertices, Float32Array);
  const texcoords = createAugmentedTypedArray(2, numVertices, Float32Array);
  const indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);
  let firstIndex = 0;
  const radiusSpan = radius - innerRadius;
  const pointsPerStack = divisions + 1;
  for (let stack = 0; stack <= stacks; ++stack) {
    const stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);
    for (let i = 0; i <= divisions; ++i) {
      const theta = 2 * Math.PI * i / divisions;
      const x = stackRadius * Math.cos(theta);
      const z = stackRadius * Math.sin(theta);
      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - i / divisions, stack / stacks);
      if (stack > 0 && i !== divisions) {
        const a = firstIndex + (i + 1);
        const b2 = firstIndex + i;
        const c = firstIndex + i - pointsPerStack;
        const d = firstIndex + (i + 1) - pointsPerStack;
        indices.push(a, b2, c);
        indices.push(a, c, d);
      }
    }
    firstIndex += divisions + 1;
  }
  return {
    position: positions.typedArray,
    normal: normals.typedArray,
    texcoord: texcoords.typedArray,
    indices: indices.typedArray
  };
}
var primitives = Object.freeze({
  __proto__: null,
  TypedArrayWrapper,
  create3DFVertices,
  createCrescentVertices,
  createCubeVertices,
  createCylinderVertices,
  createDiscVertices,
  createPlaneVertices,
  createSphereVertices,
  createTorusVertices,
  createTruncatedConeVertices,
  createXYQuadVertices
});
export {
  TypedArrayViewGenerator,
  copySourceToTexture,
  copySourcesToTexture,
  createBufferLayoutsFromArrays,
  createBuffersAndAttributesFromArrays,
  createTextureFromImage,
  createTextureFromImages,
  createTextureFromSource,
  createTextureFromSources,
  generateMipmap,
  getSizeForMipFromTexture,
  getSizeFromSource,
  interleaveVertexData,
  isTypedArray,
  loadImageBitmap,
  makeShaderDataDefinitions,
  makeStructuredView,
  makeTypedArrayViews,
  normalizeGPUExtent3D,
  numMipLevels,
  primitives,
  setStructuredValues,
  setStructuredView,
  subarray
};
//# sourceMappingURL=webgpu-utils.js.map
